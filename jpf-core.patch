diff -r 5b3e52c6ffaa .classpath
--- a/.classpath	Sat Jun 04 12:38:48 2011 -0700
+++ b/.classpath	Sun Jun 12 10:40:51 2011 +0200
@@ -8,5 +8,29 @@
 	<classpathentry kind="src" output="build/tests" path="src/tests"/>
 	<classpathentry exported="true" kind="lib" path="lib/junit-4.6.jar"/>
 	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="lib" path="tools/ant-junit.jar"/>
+	<classpathentry kind="lib" path="tools/ant-launcher.jar"/>
+	<classpathentry kind="lib" path="tools/ant-nodeps.jar"/>
+	<classpathentry kind="lib" path="tools/ant.jar"/>
+	<classpathentry kind="lib" path="tools/dom4j-1.6.1.jar"/>
+	<classpathentry kind="lib" path="tools/xml-apis.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/aima-core.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/automaton.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/bcel.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/choco-1_2_04.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/choco-solver-2.1.1-20100709.142532-2.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/commons-lang-2.4.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/commons-math-1.2.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/coral.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/hampi.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/iasolver.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/libcvc3.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/opt4j-2.2.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/org.sat4j.core.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/org.sat4j.pb.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/scale.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/STPJNI.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/string.jar"/>
+	<classpathentry kind="lib" path="/jpf-symbc/lib/yicesapijava.jar"/>
 	<classpathentry kind="output" path="build/main"/>
 </classpath>
diff -r 5b3e52c6ffaa jpf.properties
--- a/jpf.properties	Sat Jun 04 12:38:48 2011 -0700
+++ b/jpf.properties	Sun Jun 12 10:40:51 2011 +0200
@@ -23,7 +23,7 @@
 
 jpf-core.classpath=\
   ${jpf-core}/build/jpf-classes.jar;\
-  ${jpf-core}/build/examples
+  ${jpf-core}/build/examples;
 
 jpf-core.sourcepath=\
   ${jpf-core}/src/examples
diff -r 5b3e52c6ffaa src/main/gov/nasa/jpf/jvm/ClassInfo.java
--- a/src/main/gov/nasa/jpf/jvm/ClassInfo.java	Sat Jun 04 12:38:48 2011 -0700
+++ b/src/main/gov/nasa/jpf/jvm/ClassInfo.java	Sun Jun 12 10:40:51 2011 +0200
@@ -54,7 +54,6 @@
 import java.util.jar.JarFile;
 import java.util.logging.Level;
 
-
 /**
  * Describes the JVM's view of a java class.  Contains descriptions of the
  * static and dynamic fields, methods, and information relevant to the
@@ -1004,6 +1003,32 @@
   public ClassInfo getClassInfo() {
     return this;
   }
+  
+  public static synchronized ClassInfo getClassInfo (String className) {
+	    if (className == null) {
+	      return null;
+	    }
+
+	    String typeName = Types.getCanonicalTypeName(className);
+
+	    // <2do> this is BAD - fix it!
+	    int idx = JVM.getVM().getStaticArea().indexFor(typeName);
+
+	    ClassInfo ci = loadedClasses.get(idx);
+
+	    if (ci != null) {
+	      return ci;
+
+	    } else if (isBuiltinClass(typeName)) {
+	      // this is a array or builtin type class - there's no class file for this, it
+	      // gets automatically generated by the VM
+	      return new ClassInfo(typeName, idx);
+
+	    } else {
+	        return new ClassInfo(className, idx);
+	    }
+	  }
+
 
   boolean getAssertionStatus () {
     return StringSetMatcher.isMatch(name, enabledAssertionPatterns, disabledAssertionPatterns);
diff -r 5b3e52c6ffaa src/main/gov/nasa/jpf/jvm/Types.java
--- a/src/main/gov/nasa/jpf/jvm/Types.java	Sat Jun 04 12:38:48 2011 -0700
+++ b/src/main/gov/nasa/jpf/jvm/Types.java	Sun Jun 12 10:40:51 2011 +0200
@@ -959,5 +959,95 @@
 
     throw new JPFException("invalid method declaration: " + methodDecl);
   }
-  
+
+  public static String getTypeCode (String type, boolean dotNotation) {
+	    String  t = null;
+	    int arrayDim = 0;
+	    
+	    type = dotNotation ? type.replace('/', '.') : type.replace('.', '/');
+	    
+	    if ((type.charAt(0) == '[') || (type.endsWith(";"))) {  // [[[L...;
+	      t = type;
+	    } else {
+	      
+	      while (type.endsWith("[]")) { // type[][][]
+	        type = type.substring(0, type.length() - 2);
+	        arrayDim++;
+	      }
+	      
+	      if (type.equals("byte")) {
+	        t = "B";
+	      } else if (type.equals("char")) {
+	        t = "C";
+	      } else if (type.equals("short")) {
+	        t = "S";
+	      } else if (type.equals("int")) {
+	        t = "I";
+	      } else if (type.equals("float")) {
+	        t = "F";
+	      } else if (type.equals("long")) {
+	        t = "J";
+	      } else if (type.equals("double")) {
+	        t = "D";
+	      } else if (type.equals("boolean")) {
+	        t = "Z";
+	      } else if (type.equals("void")) {
+	        t = "V";
+	      } else if (type.endsWith(";")) {
+	        t = type;
+	      }
+	      
+	      while (arrayDim-- > 0) {
+	        t = "[" + t;
+	      }
+	      
+	      if (t == null) {
+	        t = "L" + type + ';';
+	      }
+	    }
+
+	    return t;
+	  }
+
+  public static String getCanonicalTypeName (String typeName) {
+	    typeName = typeName.replace('/','.');
+	    int n = typeName.length()-1;
+	    
+	    if (typeName.charAt(0) == '['){ // the "[<type>" notation
+	      if (typeName.charAt(1) == 'L'){
+	        if (typeName.charAt(n) != ';'){
+	          typeName = typeName + ';';
+	        }
+	      }
+	      
+	      return typeName;
+	    }
+	    
+	    int i=typeName.indexOf('[');
+	    if (i>0){ // the sort of "<type>[]"
+	      StringBuilder sb = new StringBuilder();
+	      sb.append('[');
+	      for (int j=i; (j=typeName.indexOf('[',j+1)) >0;){
+	        sb.append('[');
+	      }
+	      
+	      typeName = typeName.substring(0,i);
+	      if (isBasicType(typeName)){
+	        sb.append( getTypeCode(typeName, true));
+	      } else {
+	        sb.append('L');
+	        sb.append(typeName);
+	        sb.append(';');
+	      }
+	      
+	      return sb.toString();
+	    }
+	    
+	    if (typeName.charAt(n) == ';') {
+	      return typeName.substring(1,n);
+	    }
+	    
+	    return typeName;
+	  }
+
 }
diff -r 5b3e52c6ffaa src/main/gov/nasa/jpf/jvm/bytecode/InvokeInstruction.java
--- a/src/main/gov/nasa/jpf/jvm/bytecode/InvokeInstruction.java	Sat Jun 04 12:38:48 2011 -0700
+++ b/src/main/gov/nasa/jpf/jvm/bytecode/InvokeInstruction.java	Sun Jun 12 10:40:51 2011 +0200
@@ -144,6 +144,8 @@
     MethodInfo callee = getInvokedMethod(ti);
     StackFrame frame = getCallerFrame(ti, callee);
 
+    if (frame == null)
+    	return new Object[] {};
     assert frame != null : "can't find caller stackframe for: " + this;
     return getArgsFromCaller(ti, frame, callee);
   }
diff -r 5b3e52c6ffaa src/main/gov/nasa/jpf/util/Pair.java
--- a/src/main/gov/nasa/jpf/util/Pair.java	Sat Jun 04 12:38:48 2011 -0700
+++ b/src/main/gov/nasa/jpf/util/Pair.java	Sun Jun 12 10:40:51 2011 +0200
@@ -32,4 +32,9 @@
   public final int hashCode() {
     return Misc.hashCode(a) ^ Misc.hashCode(b);
   }
+  
+  @Override
+  public String toString() {
+	return "(" + a.toString() + "," + b.toString() + ")";
+  }  
 }
