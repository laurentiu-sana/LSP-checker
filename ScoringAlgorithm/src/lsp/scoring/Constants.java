package lsp.scoring;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.RandomAccessFile;

/**
 * Constants used by the scoring algorithm for classes.
 */
public class Constants {
	public final static String CONFIG_FILE = "lsp.properties";

	public final static String CLASS_STR = "java.lang.Class";
	public final static String OBJECT_STR = "java.lang.Object";
	public final static String STRING_ARRAY_STR = "java.lang.String[]";

	public static Boolean DEBUG = false;
	public static Boolean INSANE_DEBUG = false;
	public static String DEBUG_FOLDER = "log";
	public static String TESTS_CLASSPATH = "tests/classes";
	public static String OUTPUT_FOLDER = "results";
	public static String GENERATED_TESTS_FOLDER = "generated_tests";
	public static String TESTS_PACKAGE = "lsp/scoring/tests";
	public static double THRESHOLD_SCORE = 0.0;
	public static String TEST_NAME = null;
	public static Integer MAX_METHODS_NUMBER = 0;
	public static Integer MAX_METHODS_TESTS = 0;

	/**
	 * @brief Influence in class's score of implemented interfaces
	 * 
	 * class A {} scores 1.0
	 * 
	 * class B implements Interface {} scores 1.8
	 * 
	 * class C extends A {} scores 2.0
	 * 
	 * interface Interface1 {} scores 1.0
	 * interface Interface2 extends Interface1 {} scores 1.8 (1.0 + 0.6 * 1.0)
	 * class D extends Class implements Interface2 {} scores 2.44 (1.0 + 0.6 * 1.6)
	 */
	public final static Double INTERFACE_POLYMORPHIC = 0.6;

	/**
	 * @brief Influence in class's score of contained fields
	 * 
	 * class A {} 
	 * class B extends A { private B parent; } initially scores 2.0,
	 * but after fields crawling it scores 2.3 (2.0 + 0.3)
	 */
	public final static Double FIELD_POLYMORPHIC = 0.3;

	/**
	 * @brief Influence in class's score of contained public methods
	 * 
	 * class B { public void method(field 1, .. , field N); } scores
	 *   initial_score(B) + 0.2 * (initial_score(field 1) + initial_scoare(field N))
	 * */
	public final static Double METHOD_POLYMORPHIC = 0.2;

	/**
	 * @brief Influence of parameter's type is array.
	 */
	public final static Double METHOD_ARRAY_FIELD = 0.15;

	public static final String TMP_FILE = "/tmp/lsp_checker";
	public static final String TMP_UNIQ_FILE = "/tmp/lsp_checker_uniq";

	public static final int BUFFER_SIZE = 1024;

	public static final String TEST_HEADER = "/** Test case generated by the LSP checker; feel free to hack it! */\n";

	public static final String MAIN_LSP_CHECKER = "mainLSPChecker";
	public static final String MAIN_LSP_CHECKER2 = "mainLSPChecker2";

	static class WorkerThread extends Thread {
		private String cmd, input, output;
		public int result;

		public WorkerThread(String cmd, String input, String output) {
			result = -1;
			this.cmd = cmd;
			this.input = input;
			this.output = output;
		}

		@Override
		public void run() {
			try {
				Process proc = Runtime.getRuntime().exec(cmd);
				if (input != null) {
					OutputStream stdin = proc.getOutputStream();
					stdin.write(input.getBytes());
					stdin.flush();
					stdin.close();
				}
				if (output != null) {
					RandomAccessFile raf = new RandomAccessFile(output, "rw");
					raf.setLength(0);
					InputStream stdout = proc.getInputStream();
					byte buffer[] = new byte[Constants.BUFFER_SIZE];
					int size = -1;

					while (true) {
						size = stdout.read(buffer);
						if (size <= 0)
							break;
						raf.write(buffer, 0, size);
					}
					raf.close();
				}
				result = proc.waitFor();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	public static int execAndWait(String cmd) {
		return Constants.execAndWait(cmd, null, null, 500);
	}

	public static int execAndWaitWithInput(String cmd, String input) {
		// Wait 30s seconds to unzip
		return execAndWait(cmd, input, null, 30 * 1000);
	}

	public static int execAndWaitWithOutputRedirected(String cmd, String output) {
		// Wait 30s seconds to unzip
		return execAndWait(cmd, null, output, 30 * 1000);
	}

	public static int execAndWait(String cmd, String input, String output,
			int timeout) {
		try {
			WorkerThread thread = new WorkerThread(cmd, input, output);
			thread.start();
			thread.join(timeout);
			return thread.result;
		} catch (Exception e) {
			e.printStackTrace();
			return -1;
		}
	}

	public static void pause() {
		try {
			System.in.read();
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}
