lsp.tests.LSPCheckerGeneratedTestJDK
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ICUResourceBundle createBundleObject(java.lang.String,long,java.lang.String,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle,lsp.test.jdk.util.ICUResourceBundle,boolean[])> scored 1488.3468156000008
<lsp.test.jdk.util.ICUResourceBundle: void assign(lsp.test.jdk.util.ICUResourceBundle,lsp.test.jdk.util.ICUResourceBundle)> scored 1349.5448156000007
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ICUResourceBundle findResourceWithFallback(java.lang.String,lsp.test.jdk.util.UResourceBundle,lsp.test.jdk.util.UResourceBundle)> scored 869.0764078000004
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ICUResourceBundle findResource(java.lang.String,long,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle)> scored 813.5744078000004
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle findBundle(lsp.test.jdk.util.ResourceBundle$CacheKey,lsp.test.jdk.util.List,lsp.test.jdk.util.List,int,lsp.test.jdk.util.ResourceBundle$Control,lsp.test.jdk.util.ResourceBundle)> scored 699.6781665279998
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle putBundleInCache(lsp.test.jdk.util.ResourceBundle$CacheKey,lsp.test.jdk.util.ResourceBundle,lsp.test.jdk.util.ResourceBundle$Control)> scored 691.6781665279998
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ICUResourceBundle getBundle(java.lang.Object,java.lang.String,java.lang.String,java.lang.ClassLoader)> scored 679.7724078000003
<lsp.test.jdk.util.ULocale: java.lang.String getTableString(java.lang.String,java.lang.String,java.lang.String,lsp.test.jdk.util.ICUResourceBundle)> scored 674.7724078000003
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ICUResourceBundle getWithFallback(java.lang.String)> scored 674.7724078000003
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ICUResourceBundle createBundle(java.lang.String,java.lang.String,java.lang.ClassLoader)> scored 674.7724078000003
<lsp.test.jdk.util.ICUResourceBundle: int findKey(int,int,lsp.test.jdk.util.ICUResourceBundle,java.lang.String)> scored 674.7724078000003
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle getBundle(java.lang.String,lsp.test.jdk.util.Locale,lsp.test.jdk.util.ResourceBundle$Control)> scored 419.8563770639999
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle getBundle(java.lang.String,lsp.test.jdk.util.Locale,java.lang.ClassLoader,lsp.test.jdk.util.ResourceBundle$Control)> scored 419.8563770639999
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle getBundleImpl(java.lang.String,lsp.test.jdk.util.Locale,java.lang.ClassLoader,lsp.test.jdk.util.ResourceBundle$Control)> scored 419.8563770639999
<lsp.test.jdk.util.ResourceBundle$Control: lsp.test.jdk.util.ResourceBundle newBundle(java.lang.String,lsp.test.jdk.util.Locale,java.lang.String,java.lang.ClassLoader,boolean)> scored 402.0563770639999
<lsp.test.jdk.util.ResourceBundle$Control: boolean needsReload(java.lang.String,lsp.test.jdk.util.Locale,java.lang.String,java.lang.ClassLoader,lsp.test.jdk.util.ResourceBundle,long)> scored 402.0563770639999
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle getBundle(java.lang.String,lsp.test.jdk.util.Locale)> scored 402.0563770639999
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle getBundle(java.lang.String,lsp.test.jdk.util.Locale,java.lang.ClassLoader)> scored 402.0563770639999
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle loadBundle(lsp.test.jdk.util.ResourceBundle$CacheKey,lsp.test.jdk.util.List,lsp.test.jdk.util.ResourceBundle$Control,boolean)> scored 371.04801746399994
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle findBundleInCache(lsp.test.jdk.util.ResourceBundle$CacheKey,lsp.test.jdk.util.ResourceBundle$Control)> scored 367.04801746399994
<lsp.test.jdk.util.ResourceBundle$BundleReference: void <init>(lsp.test.jdk.util.ResourceBundle,java.lang.ref.ReferenceQueue,lsp.test.jdk.util.ResourceBundle$CacheKey)> scored 349.24801746399993
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle getBundle(java.lang.String,lsp.test.jdk.util.ResourceBundle$Control)> scored 342.4301490639999
<lsp.test.jdk.util.ICUResourceBundle: void setParent(lsp.test.jdk.util.ResourceBundle)> scored 324.6301490639999
<lsp.test.jdk.util.ResourceBundle: void setParent(lsp.test.jdk.util.ResourceBundle)> scored 324.6301490639999
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.ResourceBundle getBundle(java.lang.String)> scored 324.6301490639999
<lsp.test.jdk.util.ResourceBundle: boolean isValidBundle(lsp.test.jdk.util.ResourceBundle)> scored 324.6301490639999
<lsp.test.jdk.util.ResourceBundle: boolean hasValidParentChain(lsp.test.jdk.util.ResourceBundle)> scored 324.6301490639999
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.Calendar getInstance(lsp.test.jdk.util.TimeZone,lsp.test.jdk.util.Locale)> scored 294.2578638000001
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.Calendar getInstance(lsp.test.jdk.util.Locale)> scored 254.68737260000006
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale acceptLanguage(lsp.test.jdk.util.ULocale[],lsp.test.jdk.util.ULocale[],boolean[])> scored 254.53560000000002
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle handleGet(java.lang.String,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle)> scored 235.9540000000001
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle handleGet(int,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle)> scored 235.9540000000001
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle get(java.lang.String,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle)> scored 235.9540000000001
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle handleGet(java.lang.String,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle)> scored 235.9540000000001
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle handleGet(int,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle)> scored 235.9540000000001
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle handleGetImpl(java.lang.String,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle,int[],boolean[])> scored 235.9540000000001
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle handleGetImpl(int,lsp.test.jdk.util.HashMap,lsp.test.jdk.util.UResourceBundle,boolean[])> scored 235.9540000000001
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.Calendar getInstance(lsp.test.jdk.util.TimeZone)> scored 216.83163580000007
<lsp.test.jdk.util.sql.PreparedStatement: void setTimestamp(int,lsp.test.jdk.util.sql.Timestamp,lsp.test.jdk.util.Calendar)> scored 186.22114460000006
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Timestamp getTimestamp(int,lsp.test.jdk.util.Calendar)> scored 186.22114460000006
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Timestamp getTimestamp(java.lang.String,lsp.test.jdk.util.Calendar)> scored 186.22114460000006
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getCurrencyInstance(lsp.test.jdk.util.Locale)> scored 182.70048844000004
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getIntegerInstance(lsp.test.jdk.util.Locale)> scored 182.70048844000004
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getInstance(lsp.test.jdk.util.Locale)> scored 182.70048844000004
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getNumberInstance(lsp.test.jdk.util.Locale)> scored 182.70048844000004
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getPercentInstance(lsp.test.jdk.util.Locale)> scored 182.70048844000004
<lsp.test.jdk.util.sql.PreparedStatement: void setDate(int,lsp.test.jdk.util.sql.Date,lsp.test.jdk.util.Calendar)> scored 178.86114460000005
<lsp.test.jdk.util.sql.PreparedStatement: void setTime(int,lsp.test.jdk.util.sql.Time,lsp.test.jdk.util.Calendar)> scored 178.86114460000005
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Date getDate(int,lsp.test.jdk.util.Calendar)> scored 178.86114460000005
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Date getDate(java.lang.String,lsp.test.jdk.util.Calendar)> scored 178.86114460000005
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Time getTime(int,lsp.test.jdk.util.Calendar)> scored 178.86114460000005
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Time getTime(java.lang.String,lsp.test.jdk.util.Calendar)> scored 178.86114460000005
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Locale[] getLocaleList(lsp.test.jdk.util.ULocale[])> scored 177.7419622
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.Calendar getCalendar()> scored 177.26114460000005
<lsp.test.jdk.util.DateFormat: void setCalendar(lsp.test.jdk.util.Calendar)> scored 177.26114460000005
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.Calendar getInstance()> scored 177.26114460000005
<lsp.test.jdk.util.Calendar: int compareTo(lsp.test.jdk.util.Calendar)> scored 177.26114460000005
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,lsp.test.jdk.util.Locale)> scored 174.57822800000005
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,lsp.test.jdk.util.Locale,java.lang.ClassLoader)> scored 174.57822800000005
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(lsp.test.jdk.util.ULocale)> scored 174.28400000000005
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,lsp.test.jdk.util.ULocale)> scored 174.28400000000005
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,lsp.test.jdk.util.ULocale,java.lang.ClassLoader)> scored 174.28400000000005
<lsp.test.jdk.util.UResourceBundle: void addToCache(java.lang.ClassLoader,java.lang.String,lsp.test.jdk.util.ULocale,lsp.test.jdk.util.UResourceBundle)> scored 174.28400000000005
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle loadFromCache(java.lang.ClassLoader,java.lang.String,lsp.test.jdk.util.ULocale)> scored 174.28400000000005
<lsp.test.jdk.util.DateFormatSymbols: lsp.test.jdk.util.DateFormatSymbols getInstance(lsp.test.jdk.util.Locale)> scored 166.41802968000002
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale acceptLanguage(java.lang.String,lsp.test.jdk.util.ULocale[],boolean[])> scored 165.8338
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale acceptLanguage(lsp.test.jdk.util.ULocale[],boolean[])> scored 165.8338
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getCharacterInstance(lsp.test.jdk.util.Locale)> scored 165.67524284000004
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getLineInstance(lsp.test.jdk.util.Locale)> scored 165.67524284000004
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getSentenceInstance(lsp.test.jdk.util.Locale)> scored 165.67524284000004
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getWordInstance(lsp.test.jdk.util.Locale)> scored 165.67524284000004
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getDateInstance(int,lsp.test.jdk.util.Locale)> scored 158.18999724000003
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getDateTimeInstance(int,int,lsp.test.jdk.util.Locale)> scored 158.18999724000003
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getTimeInstance(int,lsp.test.jdk.util.Locale)> scored 158.18999724000003
<lsp.test.jdk.util.ResourceBundle$NoFallbackControl: lsp.test.jdk.util.Locale getFallbackLocale(java.lang.String,lsp.test.jdk.util.Locale)> scored 154.85245600000002
<lsp.test.jdk.util.ResourceBundle$Control: lsp.test.jdk.util.Locale getFallbackLocale(java.lang.String,lsp.test.jdk.util.Locale)> scored 154.85245600000002
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale forLocale(lsp.test.jdk.util.Locale)> scored 154.558228
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale addLikelySubtags(lsp.test.jdk.util.ULocale)> scored 154.264
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale minimizeSubtags(lsp.test.jdk.util.ULocale)> scored 154.264
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ULocale getFunctionalEquivalent(java.lang.String,java.lang.String,java.lang.String,lsp.test.jdk.util.ULocale,boolean[],boolean)> scored 154.264
<lsp.test.jdk.util.TreeMap$AscendingSubMap: void <init>(lsp.test.jdk.util.TreeMap,boolean,java.lang.Object,boolean,boolean,java.lang.Object,boolean)> scored 126.34399999999994
<lsp.test.jdk.util.TreeMap$DescendingSubMap: void <init>(lsp.test.jdk.util.TreeMap,boolean,java.lang.Object,boolean,boolean,java.lang.Object,boolean)> scored 126.34399999999994
<lsp.test.jdk.util.TreeMap$NavigableSubMap: void <init>(lsp.test.jdk.util.TreeMap,boolean,java.lang.Object,boolean,boolean,java.lang.Object,boolean)> scored 126.34399999999994
<lsp.test.jdk.util.UResourceBundle: void addToCache(lsp.test.jdk.util.UResourceBundle$ResourceCacheKey,lsp.test.jdk.util.UResourceBundle)> scored 121.29160000000005
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle loadFromCache(lsp.test.jdk.util.UResourceBundle$ResourceCacheKey)> scored 121.29160000000005
<lsp.test.jdk.util.TreeMap$KeyIterator: void <init>(lsp.test.jdk.util.TreeMap,lsp.test.jdk.util.TreeMap$Entry)> scored 121.24399999999994
<lsp.test.jdk.util.TreeMap$ValueIterator: void <init>(lsp.test.jdk.util.TreeMap,lsp.test.jdk.util.TreeMap$Entry)> scored 121.24399999999994
<lsp.test.jdk.util.TreeMap$EntryIterator: void <init>(lsp.test.jdk.util.TreeMap,lsp.test.jdk.util.TreeMap$Entry)> scored 121.24399999999994
<lsp.test.jdk.util.TreeMap: void access$000(lsp.test.jdk.util.TreeMap,lsp.test.jdk.util.TreeMap$Entry)> scored 121.24399999999994
<lsp.test.jdk.util.TreeMap$DescendingKeyIterator: void <init>(lsp.test.jdk.util.TreeMap,lsp.test.jdk.util.TreeMap$Entry)> scored 121.24399999999994
<lsp.test.jdk.util.TreeMap$PrivateEntryIterator: void <init>(lsp.test.jdk.util.TreeMap,lsp.test.jdk.util.TreeMap$Entry)> scored 121.24399999999994
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Comparator access$200(lsp.test.jdk.util.TreeMap)> scored 118.34399999999994
<lsp.test.jdk.util.GregorianCalendar: void <init>(lsp.test.jdk.util.TimeZone,lsp.test.jdk.util.Locale)> scored 116.99671920000003
<lsp.test.jdk.util.Calendar: void <init>(lsp.test.jdk.util.TimeZone,lsp.test.jdk.util.Locale)> scored 116.99671920000003
<lsp.test.jdk.util.TreeMap$EntrySet: void <init>(lsp.test.jdk.util.TreeMap)> scored 116.34399999999994
<lsp.test.jdk.util.TreeMap$Values: void <init>(lsp.test.jdk.util.TreeMap)> scored 116.34399999999994
<lsp.test.jdk.util.TreeMap: int access$100(lsp.test.jdk.util.TreeMap)> scored 116.34399999999994
<lsp.test.jdk.util.TreeMap$SubMap: void <init>(lsp.test.jdk.util.TreeMap)> scored 116.34399999999994
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.NumberFormat getNumberFormat()> scored 105.27426044000003
<lsp.test.jdk.util.DateFormat: void setNumberFormat(lsp.test.jdk.util.NumberFormat)> scored 105.27426044000003
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getCurrencyInstance()> scored 105.27426044000003
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getIntegerInstance()> scored 105.27426044000003
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getInstance()> scored 105.27426044000003
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getNumberInstance()> scored 105.27426044000003
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.NumberFormat getPercentInstance()> scored 105.27426044000003
<lsp.test.jdk.util.UResourceBundle: java.lang.Object handleGetObjectImpl(java.lang.String,lsp.test.jdk.util.UResourceBundle)> scored 102.15200000000004
<lsp.test.jdk.util.UResourceBundle: java.lang.Object resolveObject(java.lang.String,lsp.test.jdk.util.UResourceBundle)> scored 102.15200000000004
<lsp.test.jdk.util.ResourceBundle$CacheKey: lsp.test.jdk.util.ResourceBundle$CacheKey setLocale(lsp.test.jdk.util.Locale)> scored 102.04409640000002
<lsp.test.jdk.util.UResourceBundle$ResourceCacheKey: void access$000(lsp.test.jdk.util.UResourceBundle$ResourceCacheKey,java.lang.ClassLoader,java.lang.String,lsp.test.jdk.util.ULocale)> scored 101.2716
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,java.lang.String)> scored 97.15200000000004
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,java.lang.String,java.lang.ClassLoader)> scored 97.15200000000004
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,java.lang.String,java.lang.ClassLoader,boolean)> scored 97.15200000000004
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String)> scored 97.15200000000004
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle getParent()> scored 97.15200000000004
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle instantiateBundle(java.lang.String,java.lang.String,java.lang.ClassLoader,boolean)> scored 97.15200000000004
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle get(java.lang.String)> scored 97.15200000000004
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.UResourceBundle get(int)> scored 97.15200000000004
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle getBundleInstance(java.lang.String,java.lang.String,java.lang.ClassLoader,boolean)> scored 97.15200000000004
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle instantiateBundle(java.lang.String,java.lang.String,java.lang.ClassLoader,boolean)> scored 97.15200000000004
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.UResourceBundle getParent()> scored 97.15200000000004
<lsp.test.jdk.util.Locale: lsp.test.jdk.util.Locale[] getAvailableLocales()> scored 89.0401622
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.Locale[] getAvailableLocales()> scored 89.0401622
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Locale[] getAvailableLocales(java.lang.String)> scored 89.0401622
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Locale[] getAvailableLocales()> scored 89.0401622
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Locale[] createLocaleList(java.lang.String)> scored 89.0401622
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Locale[] access$100(java.lang.String)> scored 89.0401622
<lsp.test.jdk.util.ICUResourceBundle$AvailEntry: lsp.test.jdk.util.Locale[] getLocaleList()> scored 89.0401622
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.Locale[] getAvailableLocales()> scored 89.0401622
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.Locale[] getAvailableLocales()> scored 89.0401622
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.Locale[] getAvailableLocales()> scored 89.0401622
<lsp.test.jdk.util.DateFormatSymbols: lsp.test.jdk.util.Locale[] getAvailableLocales()> scored 89.0401622
<lsp.test.jdk.util.DateFormatSymbols: void initBuildInLocales(lsp.test.jdk.util.Locale[])> scored 89.0401622
<lsp.test.jdk.util.SimpleDateFormat: void <init>(java.lang.String,lsp.test.jdk.util.DateFormatSymbols)> scored 88.99180168000002
<lsp.test.jdk.util.SimpleDateFormat: lsp.test.jdk.util.DateFormatSymbols getDateFormatSymbols()> scored 88.99180168000002
<lsp.test.jdk.util.SimpleDateFormat: void setDateFormatSymbols(lsp.test.jdk.util.DateFormatSymbols)> scored 88.99180168000002
<lsp.test.jdk.util.DateFormatSymbols: lsp.test.jdk.util.DateFormatSymbols getInstance()> scored 88.99180168000002
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale[] getAvailableLocales()> scored 88.7018
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale[] parseAcceptLanguage(java.lang.String,boolean)> scored 88.7018
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ULocale[] getAvailableULocales(java.lang.String)> scored 88.7018
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ULocale[] getAvailableULocales()> scored 88.7018
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ULocale[] createULocaleList(java.lang.String,java.lang.ClassLoader)> scored 88.7018
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ULocale[] access$000(java.lang.String,java.lang.ClassLoader)> scored 88.7018
<lsp.test.jdk.util.ICUResourceBundle$AvailEntry: lsp.test.jdk.util.ULocale[] getULocaleList()> scored 88.7018
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getCharacterInstance()> scored 88.24901484000003
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getLineInstance()> scored 88.24901484000003
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getSentenceInstance()> scored 88.24901484000003
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.BreakIterator getWordInstance()> scored 88.24901484000003
<lsp.test.jdk.util.sql.Driver: lsp.test.jdk.util.sql.DriverPropertyInfo[] getPropertyInfo(java.lang.String,lsp.test.jdk.util.Properties)> scored 83.11305999999998
<lsp.test.jdk.util.sql.Driver: lsp.test.jdk.util.sql.Connection connect(java.lang.String,lsp.test.jdk.util.Properties)> scored 82.96305999999997
<lsp.test.jdk.util.sql.DriverManager: lsp.test.jdk.util.sql.Connection getConnection(java.lang.String,lsp.test.jdk.util.Properties)> scored 82.96305999999997
<lsp.test.jdk.util.SimpleDateFormat: void <init>(lsp.test.jdk.util.Locale,java.lang.Object)> scored 82.42622800000001
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.Map getDisplayNames(int,int,lsp.test.jdk.util.Locale)> scored 82.42622800000001
<lsp.test.jdk.util.DateFormatSymbols: void <init>(lsp.test.jdk.util.Locale,java.lang.Object)> scored 82.42622800000001
<lsp.test.jdk.util.Properties$LineReader: void <init>(lsp.test.jdk.util.Properties,java.io.InputStream)> scored 81.96305999999997
<lsp.test.jdk.util.Properties$LineReader: void <init>(lsp.test.jdk.util.Properties,java.io.Reader)> scored 81.96305999999997
<lsp.test.jdk.util.sql.Connection: void setClientInfo(lsp.test.jdk.util.Properties)> scored 81.96305999999997
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.Properties getClientInfo()> scored 81.96305999999997
<lsp.test.jdk.util.Properties: void <init>(lsp.test.jdk.util.Properties)> scored 81.96305999999997
<lsp.test.jdk.util.XMLUtils: void load(lsp.test.jdk.util.Properties,java.io.InputStream)> scored 81.96305999999997
<lsp.test.jdk.util.XMLUtils: void importProperties(lsp.test.jdk.util.Properties,org.w3c.dom.Element)> scored 81.96305999999997
<lsp.test.jdk.util.XMLUtils: void save(lsp.test.jdk.util.Properties,java.io.OutputStream,java.lang.String,java.lang.String)> scored 81.96305999999997
<lsp.test.jdk.util.ResourceBundle$Control: lsp.test.jdk.util.List getCandidateLocales(java.lang.String,lsp.test.jdk.util.Locale)> scored 81.42622800000001
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getDateInstance()> scored 80.76376924
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getDateInstance(int)> scored 80.76376924
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getDateTimeInstance()> scored 80.76376924
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getDateTimeInstance(int,int)> scored 80.76376924
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getInstance()> scored 80.76376924
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getTimeInstance()> scored 80.76376924
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.DateFormat getTimeInstance(int)> scored 80.76376924
<lsp.test.jdk.util.ULocale: void <init>(java.lang.String,lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.ULocale: void <init>(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.Locale toLocale()> scored 77.42622800000001
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.Locale getLocale()> scored 77.42622800000001
<lsp.test.jdk.util.ResourceBundle$Control: long getTimeToLive(java.lang.String,lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.ResourceBundle$Control: java.lang.String toBundleName(java.lang.String,lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.Locale: lsp.test.jdk.util.Locale getDefault()> scored 77.42622800000001
<lsp.test.jdk.util.Locale: java.lang.String getDisplayCountry(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.Locale: java.lang.String getDisplayLanguage(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.Locale: java.lang.String getDisplayName(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.Locale: java.lang.String getDisplayVariant(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.Locale: void setDefault(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.ResourceBundle$CacheKey: void <init>(java.lang.String,lsp.test.jdk.util.Locale,java.lang.ClassLoader)> scored 77.42622800000001
<lsp.test.jdk.util.ResourceBundle$CacheKey: lsp.test.jdk.util.Locale getLocale()> scored 77.42622800000001
<lsp.test.jdk.util.SimpleDateFormat: void <init>(java.lang.String,lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.SimpleDateFormat: void <init>(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.TimeZone: java.lang.String getDisplayName(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.TimeZone: java.lang.String getDisplayName(boolean,int,lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.GregorianCalendar: void <init>(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Locale getLocale()> scored 77.42622800000001
<lsp.test.jdk.util.Calendar: java.lang.String getDisplayName(int,int,lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.Locale getLocale()> scored 77.42622800000001
<lsp.test.jdk.util.ResourceBundle: void throwMissingResourceException(java.lang.String,lsp.test.jdk.util.Locale,java.lang.Throwable)> scored 77.42622800000001
<lsp.test.jdk.util.DateFormatSymbols: void <init>(lsp.test.jdk.util.Locale)> scored 77.42622800000001
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale createCanonical(java.lang.String)> scored 77.132
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale getDefault()> scored 77.132
<lsp.test.jdk.util.ULocale: void setDefault(lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale getFallback()> scored 77.132
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale setKeywordValue(java.lang.String,java.lang.String)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayLanguage(lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayLanguage(java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayScript(lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayScript(java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayCountry(lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayCountry(java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayVariant(lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayVariant(java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeyword(java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeywordValue(java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeywordValue(java.lang.String,java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayName(lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayName(java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.ULocale: lsp.test.jdk.util.ULocale acceptLanguage(java.lang.String,boolean[])> scored 77.132
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.ULocale getULocale()> scored 77.132
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ULocale getULocale()> scored 77.132
<lsp.test.jdk.util.UResourceBundle$ResourceCacheKey: void setKeyValues(java.lang.ClassLoader,java.lang.String,lsp.test.jdk.util.ULocale)> scored 77.132
<lsp.test.jdk.util.EnumMap: java.lang.Object access$500(lsp.test.jdk.util.EnumMap,java.lang.Object)> scored 71.32500000000002
<lsp.test.jdk.util.EnumMap: boolean access$900(lsp.test.jdk.util.EnumMap,java.lang.Object,java.lang.Object)> scored 71.32500000000002
<lsp.test.jdk.util.EnumMap: boolean access$1000(lsp.test.jdk.util.EnumMap,java.lang.Object,java.lang.Object)> scored 71.32500000000002
<lsp.test.jdk.util.EnumMap: java.lang.Object access$1200(lsp.test.jdk.util.EnumMap,java.lang.Object)> scored 71.32500000000002
<lsp.test.jdk.util.EnumMap: java.lang.Object[] access$600(lsp.test.jdk.util.EnumMap)> scored 67.07500000000002
<lsp.test.jdk.util.LinkedList: lsp.test.jdk.util.LinkedList$Entry access$300(lsp.test.jdk.util.LinkedList,java.lang.Object,lsp.test.jdk.util.LinkedList$Entry)> scored 64.47
<lsp.test.jdk.util.IdentityHashMap: boolean access$1300(lsp.test.jdk.util.IdentityHashMap,java.lang.Object,java.lang.Object)> scored 62.69
<lsp.test.jdk.util.IdentityHashMap: boolean access$1400(lsp.test.jdk.util.IdentityHashMap,java.lang.Object,java.lang.Object)> scored 62.69
<lsp.test.jdk.util.EnumMap$ValueIterator: void <init>(lsp.test.jdk.util.EnumMap,lsp.test.jdk.util.EnumMap$1)> scored 62.325000000000024
<lsp.test.jdk.util.EnumMap$EntrySet: void <init>(lsp.test.jdk.util.EnumMap,lsp.test.jdk.util.EnumMap$1)> scored 62.325000000000024
<lsp.test.jdk.util.EnumMap$Values: void <init>(lsp.test.jdk.util.EnumMap,lsp.test.jdk.util.EnumMap$1)> scored 62.325000000000024
<lsp.test.jdk.util.EnumMap$EntryIterator: void <init>(lsp.test.jdk.util.EnumMap,lsp.test.jdk.util.EnumMap$1)> scored 62.325000000000024
<lsp.test.jdk.util.EnumMap$KeyIterator: void <init>(lsp.test.jdk.util.EnumMap,lsp.test.jdk.util.EnumMap$1)> scored 62.325000000000024
<lsp.test.jdk.util.EnumMap$KeySet: void <init>(lsp.test.jdk.util.EnumMap,lsp.test.jdk.util.EnumMap$1)> scored 62.325000000000024
<lsp.test.jdk.util.EnumMap$EnumMapIterator: void <init>(lsp.test.jdk.util.EnumMap,lsp.test.jdk.util.EnumMap$1)> scored 62.325000000000024
<lsp.test.jdk.util.LinkedList: java.lang.Object access$200(lsp.test.jdk.util.LinkedList,lsp.test.jdk.util.LinkedList$Entry)> scored 61.370000000000005
<lsp.test.jdk.util.EnumMap: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap: lsp.test.jdk.util.EnumMap clone()> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap: int access$200(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap: int access$210(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap: java.lang.Enum[] access$1100(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap$ValueIterator: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap$EntrySet: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap$Values: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap$EntryIterator: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap$KeyIterator: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap$KeySet: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.EnumMap$EnumMapIterator: void <init>(lsp.test.jdk.util.EnumMap)> scored 61.325000000000024
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object[] access$100(lsp.test.jdk.util.IdentityHashMap)> scored 58.44
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ICUResourceBundle$AvailEntry getAvailEntry(java.lang.String)> scored 56.72258865999999
<lsp.test.jdk.util.LinkedList: lsp.test.jdk.util.LinkedList$Entry access$000(lsp.test.jdk.util.LinkedList)> scored 56.370000000000005
<lsp.test.jdk.util.LinkedList$DescendingIterator: void <init>(lsp.test.jdk.util.LinkedList,lsp.test.jdk.util.LinkedList$1)> scored 54.27
<lsp.test.jdk.util.IdentityHashMap$Values: void <init>(lsp.test.jdk.util.IdentityHashMap,lsp.test.jdk.util.IdentityHashMap$1)> scored 53.69
<lsp.test.jdk.util.IdentityHashMap$ValueIterator: void <init>(lsp.test.jdk.util.IdentityHashMap,lsp.test.jdk.util.IdentityHashMap$1)> scored 53.69
<lsp.test.jdk.util.IdentityHashMap$KeySet: void <init>(lsp.test.jdk.util.IdentityHashMap,lsp.test.jdk.util.IdentityHashMap$1)> scored 53.69
<lsp.test.jdk.util.IdentityHashMap$EntrySet: void <init>(lsp.test.jdk.util.IdentityHashMap,lsp.test.jdk.util.IdentityHashMap$1)> scored 53.69
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: void <init>(lsp.test.jdk.util.IdentityHashMap,lsp.test.jdk.util.IdentityHashMap$1)> scored 53.69
<lsp.test.jdk.util.IdentityHashMap$KeyIterator: void <init>(lsp.test.jdk.util.IdentityHashMap,lsp.test.jdk.util.IdentityHashMap$1)> scored 53.69
<lsp.test.jdk.util.IdentityHashMap$IdentityHashMapIterator: void <init>(lsp.test.jdk.util.IdentityHashMap,lsp.test.jdk.util.IdentityHashMap$1)> scored 53.69
<lsp.test.jdk.util.LinkedList: int access$100(lsp.test.jdk.util.LinkedList)> scored 53.27
<lsp.test.jdk.util.LinkedList$ListItr: void <init>(lsp.test.jdk.util.LinkedList,int)> scored 53.27
<lsp.test.jdk.util.LinkedList$DescendingIterator: void <init>(lsp.test.jdk.util.LinkedList)> scored 53.27
<lsp.test.jdk.util.IdentityHashMap$Values: void <init>(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap$ValueIterator: void <init>(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap$KeySet: void <init>(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap: int access$000(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap: int access$200(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap: int access$204(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap: int access$010(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap$EntrySet: void <init>(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: void <init>(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap$KeyIterator: void <init>(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.IdentityHashMap$IdentityHashMapIterator: void <init>(lsp.test.jdk.util.IdentityHashMap)> scored 52.69
<lsp.test.jdk.util.Hashtable: lsp.test.jdk.util.Hashtable$Entry[] access$400(lsp.test.jdk.util.Hashtable)> scored 48.2467
<lsp.test.jdk.util.ArrayDeque: java.lang.Object[] access$400(lsp.test.jdk.util.ArrayDeque)> scored 46.50000000000001
<lsp.test.jdk.util.Hashtable$ValueCollection: void <init>(lsp.test.jdk.util.Hashtable,lsp.test.jdk.util.Hashtable$1)> scored 44.3017
<lsp.test.jdk.util.Hashtable$EntrySet: void <init>(lsp.test.jdk.util.Hashtable,lsp.test.jdk.util.Hashtable$1)> scored 44.3017
<lsp.test.jdk.util.Hashtable$KeySet: void <init>(lsp.test.jdk.util.Hashtable,lsp.test.jdk.util.Hashtable$1)> scored 44.3017
<lsp.test.jdk.util.Hashtable$Enumerator: void <init>(lsp.test.jdk.util.Hashtable,int,boolean)> scored 43.3017
<lsp.test.jdk.util.Hashtable: java.util.Iterator access$100(lsp.test.jdk.util.Hashtable,int)> scored 43.3017
<lsp.test.jdk.util.Hashtable: int access$200(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Hashtable: int access$508(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Hashtable: int access$210(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Hashtable: int access$500(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Hashtable$ValueCollection: void <init>(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Hashtable$EntrySet: void <init>(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Hashtable$KeySet: void <init>(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Properties: void enumerate(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.Properties: void enumerateStringProperties(lsp.test.jdk.util.Hashtable)> scored 43.3017
<lsp.test.jdk.util.HashMap$KeyIterator: void <init>(lsp.test.jdk.util.HashMap,lsp.test.jdk.util.HashMap$1)> scored 42.650000000000006
<lsp.test.jdk.util.HashMap$ValueIterator: void <init>(lsp.test.jdk.util.HashMap,lsp.test.jdk.util.HashMap$1)> scored 42.650000000000006
<lsp.test.jdk.util.HashMap$EntryIterator: void <init>(lsp.test.jdk.util.HashMap,lsp.test.jdk.util.HashMap$1)> scored 42.650000000000006
<lsp.test.jdk.util.HashMap$KeySet: void <init>(lsp.test.jdk.util.HashMap,lsp.test.jdk.util.HashMap$1)> scored 42.650000000000006
<lsp.test.jdk.util.HashMap$EntrySet: void <init>(lsp.test.jdk.util.HashMap,lsp.test.jdk.util.HashMap$1)> scored 42.650000000000006
<lsp.test.jdk.util.HashMap$Values: void <init>(lsp.test.jdk.util.HashMap,lsp.test.jdk.util.HashMap$1)> scored 42.650000000000006
<lsp.test.jdk.util.ResourceBundle: void setExpirationTime(lsp.test.jdk.util.ResourceBundle$CacheKey,lsp.test.jdk.util.ResourceBundle$Control)> scored 42.4178684
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet copyOf(lsp.test.jdk.util.EnumSet)> scored 42.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet complementOf(lsp.test.jdk.util.EnumSet)> scored 42.0
<lsp.test.jdk.util.ArrayDeque$DescendingIterator: void <init>(lsp.test.jdk.util.ArrayDeque,lsp.test.jdk.util.ArrayDeque$1)> scored 41.75000000000001
<lsp.test.jdk.util.ArrayDeque$DeqIterator: void <init>(lsp.test.jdk.util.ArrayDeque,lsp.test.jdk.util.ArrayDeque$1)> scored 41.75000000000001
<lsp.test.jdk.util.HashMap$KeyIterator: void <init>(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$ValueIterator: void <init>(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$HashIterator: void <init>(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$EntryIterator: void <init>(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$KeySet: void <init>(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$EntrySet: void <init>(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.LinkedHashMap$Entry: void recordAccess(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.LinkedHashMap$Entry: void recordRemoval(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$Values: void <init>(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$Entry: void recordAccess(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.HashMap$Entry: void recordRemoval(lsp.test.jdk.util.HashMap)> scored 41.650000000000006
<lsp.test.jdk.util.ArrayDeque$DescendingIterator: void <init>(lsp.test.jdk.util.ArrayDeque)> scored 40.75000000000001
<lsp.test.jdk.util.ArrayDeque$DeqIterator: void <init>(lsp.test.jdk.util.ArrayDeque)> scored 40.75000000000001
<lsp.test.jdk.util.ArrayDeque: lsp.test.jdk.util.ArrayDeque clone()> scored 40.75000000000001
<lsp.test.jdk.util.ArrayDeque: int access$200(lsp.test.jdk.util.ArrayDeque)> scored 40.75000000000001
<lsp.test.jdk.util.ArrayDeque: int access$300(lsp.test.jdk.util.ArrayDeque)> scored 40.75000000000001
<lsp.test.jdk.util.ArrayDeque: boolean access$500(lsp.test.jdk.util.ArrayDeque,int)> scored 40.75000000000001
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.TimeZone getTimeZone()> scored 39.57049120000001
<lsp.test.jdk.util.DateFormat: void setTimeZone(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.TimeZone: lsp.test.jdk.util.TimeZone getDefault()> scored 39.57049120000001
<lsp.test.jdk.util.TimeZone: lsp.test.jdk.util.TimeZone getTimeZone(java.lang.String)> scored 39.57049120000001
<lsp.test.jdk.util.TimeZone: boolean hasSameRules(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.TimeZone: void setDefault(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.TimeZone: void setICUDefaultTimeZone(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.GregorianCalendar: void <init>(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.Calendar: void <init>(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.TimeZone getTimeZone()> scored 39.57049120000001
<lsp.test.jdk.util.Calendar: void setTimeZone(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.SimpleTimeZone: boolean hasSameRules(lsp.test.jdk.util.TimeZone)> scored 39.57049120000001
<lsp.test.jdk.util.PriorityQueue: java.lang.Object[] access$300(lsp.test.jdk.util.PriorityQueue)> scored 36.400000000000006
<lsp.test.jdk.util.PriorityQueue: java.lang.Object access$400(lsp.test.jdk.util.PriorityQueue,int)> scored 35.650000000000006
<lsp.test.jdk.util.ServiceLoader: lsp.test.jdk.util.LinkedHashMap access$300(lsp.test.jdk.util.ServiceLoader)> scored 32.38
<lsp.test.jdk.util.PriorityQueue$Itr: void <init>(lsp.test.jdk.util.PriorityQueue,lsp.test.jdk.util.PriorityQueue$1)> scored 31.650000000000002
<lsp.test.jdk.util.ServiceLoader$LazyIterator: void <init>(lsp.test.jdk.util.ServiceLoader,java.lang.Class,java.lang.ClassLoader,lsp.test.jdk.util.ServiceLoader$1)> scored 30.986000000000004
<lsp.test.jdk.util.PriorityQueue$Itr: void <init>(lsp.test.jdk.util.PriorityQueue)> scored 30.650000000000002
<lsp.test.jdk.util.PriorityQueue: void <init>(lsp.test.jdk.util.PriorityQueue)> scored 30.650000000000002
<lsp.test.jdk.util.PriorityQueue: int access$100(lsp.test.jdk.util.PriorityQueue)> scored 30.650000000000002
<lsp.test.jdk.util.PriorityQueue: int access$200(lsp.test.jdk.util.PriorityQueue)> scored 30.650000000000002
<lsp.test.jdk.util.ServiceLoader: lsp.test.jdk.util.ServiceLoader$LazyIterator access$500(lsp.test.jdk.util.ServiceLoader)> scored 27.486000000000004
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet noneOf(java.lang.Class)> scored 26.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet allOf(java.lang.Class)> scored 26.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet copyOf(lsp.test.jdk.util.Collection)> scored 26.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.ArrayList list(lsp.test.jdk.util.Enumeration)> scored 25.775
<lsp.test.jdk.util.ResourceBundle$LoaderReference: void <init>(java.lang.ClassLoader,java.lang.ref.ReferenceQueue,lsp.test.jdk.util.ResourceBundle$CacheKey)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$LoaderReference: lsp.test.jdk.util.ResourceBundle$CacheKey getCacheKey()> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKeyReference: lsp.test.jdk.util.ResourceBundle$CacheKey getCacheKey()> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKey: lsp.test.jdk.util.ResourceBundle$CacheKey setName(java.lang.String)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKey: java.lang.Throwable access$400(lsp.test.jdk.util.ResourceBundle$CacheKey)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKey: void access$500(lsp.test.jdk.util.ResourceBundle$CacheKey,java.lang.Throwable)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKey: long access$600(lsp.test.jdk.util.ResourceBundle$CacheKey)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKey: long access$700(lsp.test.jdk.util.ResourceBundle$CacheKey)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKey: long access$702(lsp.test.jdk.util.ResourceBundle$CacheKey,long)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$CacheKey: long access$602(lsp.test.jdk.util.ResourceBundle$CacheKey,long)> scored 24.617868400000003
<lsp.test.jdk.util.ResourceBundle$BundleReference: lsp.test.jdk.util.ResourceBundle$CacheKey getCacheKey()> scored 24.617868400000003
<lsp.test.jdk.util.ServiceLoader: lsp.test.jdk.util.ServiceLoader load(java.lang.Class,java.lang.ClassLoader)> scored 24.220000000000002
<lsp.test.jdk.util.ServiceLoader: lsp.test.jdk.util.ServiceLoader load(java.lang.Class)> scored 24.220000000000002
<lsp.test.jdk.util.ServiceLoader: lsp.test.jdk.util.ServiceLoader loadInstalled(java.lang.Class)> scored 24.220000000000002
<lsp.test.jdk.util.ServiceLoader: java.util.Iterator access$200(lsp.test.jdk.util.ServiceLoader,java.lang.Class,java.net.URL)> scored 24.220000000000002
<lsp.test.jdk.util.ServiceLoader$LazyIterator: void <init>(lsp.test.jdk.util.ServiceLoader,java.lang.Class,java.lang.ClassLoader)> scored 24.220000000000002
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.ArrayList createFullLocaleNameArray(java.lang.String,java.lang.ClassLoader)> scored 23.775
<lsp.test.jdk.util.AbstractMap$1: void <init>(lsp.test.jdk.util.AbstractMap)> scored 23.5
<lsp.test.jdk.util.AbstractMap$2: void <init>(lsp.test.jdk.util.AbstractMap)> scored 23.5
<lsp.test.jdk.util.AttributedString$AttributedIterator: void <init>(lsp.test.jdk.util.AttributedString,lsp.test.jdk.util.AttributedCharacterIterator$Attribute[],int,int)> scored 22.225
<lsp.test.jdk.util.ResourceBundle$Control: lsp.test.jdk.util.ResourceBundle$Control getControl(lsp.test.jdk.util.List)> scored 21.8
<lsp.test.jdk.util.ResourceBundle$Control: lsp.test.jdk.util.ResourceBundle$Control getNoFallbackControl(lsp.test.jdk.util.List)> scored 21.8
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet of(java.lang.Enum)> scored 21.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet of(java.lang.Enum,java.lang.Enum)> scored 21.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet of(java.lang.Enum,java.lang.Enum,java.lang.Enum)> scored 21.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet of(java.lang.Enum,java.lang.Enum,java.lang.Enum,java.lang.Enum)> scored 21.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet of(java.lang.Enum,java.lang.Enum,java.lang.Enum,java.lang.Enum,java.lang.Enum)> scored 21.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet of(java.lang.Enum,java.lang.Enum[])> scored 21.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet range(java.lang.Enum,java.lang.Enum)> scored 21.0
<lsp.test.jdk.util.EnumSet: lsp.test.jdk.util.EnumSet clone()> scored 21.0
<lsp.test.jdk.util.EnumSet$SerializationProxy: void <init>(lsp.test.jdk.util.EnumSet)> scored 21.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Map checkedMap(lsp.test.jdk.util.Map,java.lang.Class,java.lang.Class)> scored 20.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$DescendingSubMapKeyIterator: void <init>(lsp.test.jdk.util.TreeMap$NavigableSubMap,lsp.test.jdk.util.TreeMap$Entry,lsp.test.jdk.util.TreeMap$Entry)> scored 19.51
<lsp.test.jdk.util.TreeMap$NavigableSubMap$DescendingSubMapEntryIterator: void <init>(lsp.test.jdk.util.TreeMap$NavigableSubMap,lsp.test.jdk.util.TreeMap$Entry,lsp.test.jdk.util.TreeMap$Entry)> scored 19.51
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapIterator: void <init>(lsp.test.jdk.util.TreeMap$NavigableSubMap,lsp.test.jdk.util.TreeMap$Entry,lsp.test.jdk.util.TreeMap$Entry)> scored 19.51
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapKeyIterator: void <init>(lsp.test.jdk.util.TreeMap$NavigableSubMap,lsp.test.jdk.util.TreeMap$Entry,lsp.test.jdk.util.TreeMap$Entry)> scored 19.51
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapEntryIterator: void <init>(lsp.test.jdk.util.TreeMap$NavigableSubMap,lsp.test.jdk.util.TreeMap$Entry,lsp.test.jdk.util.TreeMap$Entry)> scored 19.51
<lsp.test.jdk.util.ServiceLoader$1: void <init>(lsp.test.jdk.util.ServiceLoader)> scored 19.220000000000002
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.SortedMap checkedSortedMap(lsp.test.jdk.util.SortedMap,java.lang.Class,java.lang.Class)> scored 18.0
<lsp.test.jdk.util.ResourceBundle$Control$1: void <init>(lsp.test.jdk.util.ResourceBundle$Control,boolean,java.lang.ClassLoader,java.lang.String)> scored 17.8
<lsp.test.jdk.util.ResourceBundle$NoFallbackControl: lsp.test.jdk.util.ResourceBundle$Control access$1000()> scored 17.8
<lsp.test.jdk.util.ResourceBundle$NoFallbackControl: lsp.test.jdk.util.ResourceBundle$Control access$1100()> scored 17.8
<lsp.test.jdk.util.ResourceBundle$NoFallbackControl: lsp.test.jdk.util.ResourceBundle$Control access$1200()> scored 17.8
<lsp.test.jdk.util.ResourceBundle$Control: lsp.test.jdk.util.ResourceBundle$Control access$300()> scored 17.8
<lsp.test.jdk.util.ResourceBundle$SingleFormatControl: lsp.test.jdk.util.ResourceBundle$Control access$800()> scored 17.8
<lsp.test.jdk.util.ResourceBundle$SingleFormatControl: lsp.test.jdk.util.ResourceBundle$Control access$900()> scored 17.8
<lsp.test.jdk.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int,java.lang.Class)> scored 16.5
<lsp.test.jdk.util.Arrays: java.lang.Object[] copyOfRange(java.lang.Object[],int,int,java.lang.Class)> scored 16.5
<lsp.test.jdk.util.SubList: void <init>(lsp.test.jdk.util.AbstractList,int,int)> scored 16.0
<lsp.test.jdk.util.AbstractList$Itr: void <init>(lsp.test.jdk.util.AbstractList)> scored 16.0
<lsp.test.jdk.util.RandomAccessSubList: void <init>(lsp.test.jdk.util.AbstractList,int,int)> scored 16.0
<lsp.test.jdk.util.LinkedHashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,lsp.test.jdk.util.HashMap$Entry)> scored 15.6
<lsp.test.jdk.util.HashMap$Entry: void <init>(int,java.lang.Object,java.lang.Object,lsp.test.jdk.util.HashMap$Entry)> scored 15.6
<lsp.test.jdk.util.EnumMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Collection synchronizedCollection(lsp.test.jdk.util.Collection,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Collection checkedCollection(lsp.test.jdk.util.Collection,java.lang.Class)> scored 15.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Map singletonMap(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.AbstractMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Hashtable: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Collections$CheckedMap: void <init>(lsp.test.jdk.util.Map,java.lang.Class,java.lang.Class)> scored 15.0
<lsp.test.jdk.util.Collections$CheckedMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Map: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.TreeMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Collections$SynchronizedMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Dictionary: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.HashMap: java.lang.Object put(java.lang.Object,java.lang.Object)> scored 15.0
<lsp.test.jdk.util.Hashtable: void reconstitutionPut(lsp.test.jdk.util.Hashtable$Entry[],java.lang.Object,java.lang.Object)> scored 14.945
<lsp.test.jdk.util.TreeMap$Entry: void <init>(java.lang.Object,java.lang.Object,lsp.test.jdk.util.TreeMap$Entry)> scored 14.9
<lsp.test.jdk.util.LinkedHashMap: lsp.test.jdk.util.LinkedHashMap$Entry access$100(lsp.test.jdk.util.LinkedHashMap)> scored 14.76
<lsp.test.jdk.util.Hashtable$Entry: void <init>(int,java.lang.Object,java.lang.Object,lsp.test.jdk.util.Hashtable$Entry)> scored 14.3
<lsp.test.jdk.util.LinkedHashMap$EntryIterator: void <init>(lsp.test.jdk.util.LinkedHashMap,lsp.test.jdk.util.LinkedHashMap$1)> scored 14.16
<lsp.test.jdk.util.LinkedHashMap$KeyIterator: void <init>(lsp.test.jdk.util.LinkedHashMap,lsp.test.jdk.util.LinkedHashMap$1)> scored 14.16
<lsp.test.jdk.util.LinkedHashMap$ValueIterator: void <init>(lsp.test.jdk.util.LinkedHashMap,lsp.test.jdk.util.LinkedHashMap$1)> scored 14.16
<lsp.test.jdk.util.LinkedHashMap$LinkedHashIterator: void <init>(lsp.test.jdk.util.LinkedHashMap,lsp.test.jdk.util.LinkedHashMap$1)> scored 14.16
<lsp.test.jdk.util.sql.SQLException: lsp.test.jdk.util.sql.SQLException access$000(lsp.test.jdk.util.sql.SQLException)> scored 14.04
<lsp.test.jdk.util.Collections$CheckedSortedMap: void <init>(lsp.test.jdk.util.SortedMap,java.lang.Class,java.lang.Class)> scored 14.0
<lsp.test.jdk.util.Collections$CheckedSortedMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.Collections: boolean replaceAll(lsp.test.jdk.util.List,java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.TreeMap$SubMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.SortedMap: lsp.test.jdk.util.SortedMap subMap(java.lang.Object,java.lang.Object)> scored 14.0
<lsp.test.jdk.util.Arrays: void mergeSort(java.lang.Object[],java.lang.Object[],int,int,int,lsp.test.jdk.util.Comparator)> scored 13.5
<lsp.test.jdk.util.AttributedString$AttributedIterator: void <init>(lsp.test.jdk.util.AttributedString)> scored 13.370000000000003
<lsp.test.jdk.util.LinkedHashMap$EntryIterator: void <init>(lsp.test.jdk.util.LinkedHashMap)> scored 13.16
<lsp.test.jdk.util.LinkedHashMap$KeyIterator: void <init>(lsp.test.jdk.util.LinkedHashMap)> scored 13.16
<lsp.test.jdk.util.LinkedHashMap$ValueIterator: void <init>(lsp.test.jdk.util.LinkedHashMap)> scored 13.16
<lsp.test.jdk.util.LinkedHashMap: boolean access$000(lsp.test.jdk.util.LinkedHashMap)> scored 13.16
<lsp.test.jdk.util.LinkedHashMap$LinkedHashIterator: void <init>(lsp.test.jdk.util.LinkedHashMap)> scored 13.16
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.SortedSet subSet(java.lang.Object,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.NavigableMap subMap(java.lang.Object,boolean,java.lang.Object,boolean)> scored 13.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.NavigableMap subMap(java.lang.Object,boolean,java.lang.Object,boolean)> scored 13.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Set synchronizedSet(lsp.test.jdk.util.Set,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.List synchronizedList(lsp.test.jdk.util.List,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Set checkedSet(lsp.test.jdk.util.Set,java.lang.Class)> scored 13.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.List checkedList(lsp.test.jdk.util.List,java.lang.Class)> scored 13.0
<lsp.test.jdk.util.SortedSet: lsp.test.jdk.util.SortedSet subSet(java.lang.Object,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.SortedSet subSet(java.lang.Object,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.Collections$CheckedSortedSet: lsp.test.jdk.util.SortedSet subSet(java.lang.Object,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedSet: lsp.test.jdk.util.SortedSet subSet(java.lang.Object,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.NavigableMap subMap(java.lang.Object,boolean,java.lang.Object,boolean)> scored 13.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.NavigableMap subMap(java.lang.Object,boolean,java.lang.Object,boolean)> scored 13.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: lsp.test.jdk.util.SortedSet subSet(java.lang.Object,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.NavigableSet: lsp.test.jdk.util.SortedSet subSet(java.lang.Object,java.lang.Object)> scored 13.0
<lsp.test.jdk.util.Arrays: int binarySearch(java.lang.Object[],java.lang.Object,lsp.test.jdk.util.Comparator)> scored 12.75
<lsp.test.jdk.util.Arrays: int binarySearch(java.lang.Object[],int,int,java.lang.Object,lsp.test.jdk.util.Comparator)> scored 12.75
<lsp.test.jdk.util.Arrays: int binarySearch0(java.lang.Object[],int,int,java.lang.Object,lsp.test.jdk.util.Comparator)> scored 12.75
<lsp.test.jdk.util.AttributedString: void addAttribute(lsp.test.jdk.util.AttributedCharacterIterator$Attribute,java.lang.Object)> scored 12.7
<lsp.test.jdk.util.AttributedString: void addAttribute(lsp.test.jdk.util.AttributedCharacterIterator$Attribute,java.lang.Object,int,int)> scored 12.7
<lsp.test.jdk.util.AttributedCharacterIterator: java.lang.Object getAttribute(lsp.test.jdk.util.AttributedCharacterIterator$Attribute)> scored 12.7
<lsp.test.jdk.util.AttributedString$AttributedIterator: java.lang.Object getAttribute(lsp.test.jdk.util.AttributedCharacterIterator$Attribute)> scored 12.7
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean)> scored 12.0
<lsp.test.jdk.util.Collections: java.lang.Object min(lsp.test.jdk.util.Collection,lsp.test.jdk.util.Comparator)> scored 12.0
<lsp.test.jdk.util.Collections: java.lang.Object max(lsp.test.jdk.util.Collection,lsp.test.jdk.util.Comparator)> scored 12.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean)> scored 12.0
<lsp.test.jdk.util.NavigableSet: lsp.test.jdk.util.NavigableSet subSet(java.lang.Object,boolean,java.lang.Object,boolean)> scored 12.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collections$UnmodifiableCollection: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.LinkedList: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collections$SynchronizedCollection: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collections$CheckedCollection: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Arrays: void mergeSort(java.lang.Object[],java.lang.Object[],int,int,int)> scored 11.5
<lsp.test.jdk.util.Arrays: boolean equals(java.lang.Object[],java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Arrays: java.lang.Object[] copyOf(java.lang.Object[],int)> scored 11.5
<lsp.test.jdk.util.Arrays: java.lang.Object[] copyOfRange(java.lang.Object[],int,int)> scored 11.5
<lsp.test.jdk.util.Arrays: boolean deepEquals(java.lang.Object[],java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.AbstractCollection: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.AbstractCollection: java.lang.Object[] finishToArray(java.lang.Object[],java.util.Iterator)> scored 11.5
<lsp.test.jdk.util.IdentityHashMap$EntrySet: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collections$SetFromMap: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.ArrayDeque: java.lang.Object[] copyElements(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.ArrayDeque: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collections$CopiesList: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.PriorityQueue: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.EnumMap$EntrySet: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.EnumMap$EntrySet: java.lang.Object[] fillEntryArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.ArrayList: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.List: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Arrays$ArrayList: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Set: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.Collection: java.lang.Object[] toArray(java.lang.Object[])> scored 11.5
<lsp.test.jdk.util.LinkedList: lsp.test.jdk.util.LinkedList$Entry addBefore(java.lang.Object,lsp.test.jdk.util.LinkedList$Entry)> scored 11.2
<lsp.test.jdk.util.LinkedList$Entry: void <init>(java.lang.Object,lsp.test.jdk.util.LinkedList$Entry,lsp.test.jdk.util.LinkedList$Entry)> scored 11.2
<lsp.test.jdk.util.Collections: int binarySearch(lsp.test.jdk.util.List,java.lang.Object,lsp.test.jdk.util.Comparator)> scored 11.0
<lsp.test.jdk.util.Collections: int indexedBinarySearch(lsp.test.jdk.util.List,java.lang.Object,lsp.test.jdk.util.Comparator)> scored 11.0
<lsp.test.jdk.util.Collections: int iteratorBinarySearch(lsp.test.jdk.util.List,java.lang.Object,lsp.test.jdk.util.Comparator)> scored 11.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.SortedSet checkedSortedSet(lsp.test.jdk.util.SortedSet,java.lang.Class)> scored 11.0
<lsp.test.jdk.util.AttributedString: void <init>(lsp.test.jdk.util.AttributedCharacterIterator,int,int,lsp.test.jdk.util.AttributedCharacterIterator$Attribute[])> scored 10.854999999999999
<lsp.test.jdk.util.AttributedString: lsp.test.jdk.util.AttributedCharacterIterator getIterator(lsp.test.jdk.util.AttributedCharacterIterator$Attribute[])> scored 10.854999999999999
<lsp.test.jdk.util.AttributedString: lsp.test.jdk.util.AttributedCharacterIterator getIterator(lsp.test.jdk.util.AttributedCharacterIterator$Attribute[],int,int)> scored 10.854999999999999
<lsp.test.jdk.util.Collections: boolean addAll(lsp.test.jdk.util.Collection,java.lang.Object[])> scored 10.75
<lsp.test.jdk.util.Arrays: int binarySearch(java.lang.Object[],java.lang.Object)> scored 10.75
<lsp.test.jdk.util.Arrays: int binarySearch(java.lang.Object[],int,int,java.lang.Object)> scored 10.75
<lsp.test.jdk.util.Arrays: int binarySearch0(java.lang.Object[],int,int,java.lang.Object)> scored 10.75
<lsp.test.jdk.util.Arrays: void fill(java.lang.Object[],java.lang.Object)> scored 10.75
<lsp.test.jdk.util.Arrays: void fill(java.lang.Object[],int,int,java.lang.Object)> scored 10.75
<lsp.test.jdk.util.sql.Struct: java.lang.Object[] getAttributes(lsp.test.jdk.util.Map)> scored 10.75
<lsp.test.jdk.util.HashMap: lsp.test.jdk.util.HashMap$Entry getEntry(java.lang.Object)> scored 10.6
<lsp.test.jdk.util.HashMap: lsp.test.jdk.util.HashMap$Entry removeEntryForKey(java.lang.Object)> scored 10.6
<lsp.test.jdk.util.HashMap: lsp.test.jdk.util.HashMap$Entry removeMapping(java.lang.Object)> scored 10.6
<lsp.test.jdk.util.ULocale$IDParser$1: int compare(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object lower(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object floor(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object ceiling(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object higher(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractSequentialList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: void <init>(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collator: int compare(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.Object getObject(int,lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.Object getObject(java.lang.String,lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.Hashtable$Entry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.LinkedHashMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.LinkedHashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)> scored 10.0
<lsp.test.jdk.util.LinkedHashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)> scored 10.0
<lsp.test.jdk.util.EnumMap: java.lang.Object maskNull(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.EnumMap: java.lang.Object unmaskNull(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.EnumMap: boolean containsMapping(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.EnumMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.EnumMap: java.lang.Object put(java.lang.Enum,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.EnumMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.EnumMap: boolean removeMapping(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object maskNull(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object unmaskNull(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: boolean containsMapping(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: boolean removeMapping(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: void putForCreate(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object access$600(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.LinkedList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.SimpleDateFormat: java.lang.StringBuffer formatImpl(lsp.test.jdk.util.Date,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition,java.util.Vector)> scored 10.0
<lsp.test.jdk.util.SimpleDateFormat: java.lang.StringBuffer format(lsp.test.jdk.util.Date,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition)> scored 10.0
<lsp.test.jdk.util.DateFormat: java.lang.StringBuffer format(lsp.test.jdk.util.Date,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition)> scored 10.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: void <init>(lsp.test.jdk.util.Collection,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$EmptyMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections: java.lang.Object min(lsp.test.jdk.util.Collection)> scored 10.0
<lsp.test.jdk.util.Collections: java.lang.Object max(lsp.test.jdk.util.Collection)> scored 10.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Collection unmodifiableCollection(lsp.test.jdk.util.Collection)> scored 10.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Map unmodifiableMap(lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Collection synchronizedCollection(lsp.test.jdk.util.Collection)> scored 10.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Map synchronizedMap(lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.Collections: boolean eq(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections: int frequency(lsp.test.jdk.util.Collection,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections: boolean disjoint(lsp.test.jdk.util.Collection,lsp.test.jdk.util.Collection)> scored 10.0
<lsp.test.jdk.util.Collections: boolean access$000(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Format: java.lang.Object getInternalField(java.lang.String,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$CheckedCollection: void <init>(lsp.test.jdk.util.Collection,java.lang.Class)> scored 10.0
<lsp.test.jdk.util.AbstractList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap: boolean eq(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap: boolean access$000(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Hashtable: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Hashtable: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.SubList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$ReverseComparator: int compare(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$CheckedList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$Entry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeSet: java.lang.Object lower(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeSet: java.lang.Object floor(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeSet: java.lang.Object ceiling(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeSet: java.lang.Object higher(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.Object getObject(int,lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.Object getObject(java.lang.String,lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$UnmodifiableList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.sql.Wrapper: java.lang.Object unwrap(java.lang.Class)> scored 10.0
<lsp.test.jdk.util.Collections$CheckedMap: void typeCheck(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$CheckedMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$CheckedMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Stack: java.lang.Object push(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Map$Entry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object ceilingKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object higherKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object floorKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object lowerKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$SynchronizedList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Comparator: int compare(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Map: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Map: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: java.lang.Object lowerKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: java.lang.Object floorKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: java.lang.Object ceilingKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: java.lang.Object higherKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: int compare(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.TreeMap: boolean valEquals(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableMap: java.lang.Object lowerKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableMap: java.lang.Object floorKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableMap: java.lang.Object ceilingKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableMap: java.lang.Object higherKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.EnumMap$EntryIterator: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$SingletonMap: void <init>(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$SingletonMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$ReverseComparator2: int compare(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.ICUCache: void put(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.ICUCache: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$SynchronizedMap: void <init>(lsp.test.jdk.util.Map,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$SynchronizedMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$SynchronizedMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.ArrayList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.List: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Dictionary: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Dictionary: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.Arrays$ArrayList: java.lang.Object set(int,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableSet: java.lang.Object lower(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableSet: java.lang.Object floor(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableSet: java.lang.Object ceiling(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.NavigableSet: java.lang.Object higher(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: void <init>(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.HashMap: java.lang.Object get(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.HashMap: java.lang.Object putForNullKey(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.HashMap: void putForCreate(java.lang.Object,java.lang.Object)> scored 10.0
<lsp.test.jdk.util.HashMap: java.lang.Object remove(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.HashMap: void addEntry(int,java.lang.Object,java.lang.Object,int)> scored 10.0
<lsp.test.jdk.util.HashMap: void createEntry(int,java.lang.Object,java.lang.Object,int)> scored 10.0
<lsp.test.jdk.util.HashMap$Entry: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.sql.Array: java.lang.Object getArray(long,int,lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.sql.Array: java.lang.Object getArray(lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.EnumMap$EnumMapIterator: java.lang.Object setValue(java.lang.Object)> scored 10.0
<lsp.test.jdk.util.sql.Ref: java.lang.Object getObject(lsp.test.jdk.util.Map)> scored 10.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.TreeMap$Entry subCeiling(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.TreeMap$Entry subHigher(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.TreeMap$Entry subFloor(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.TreeMap$Entry subLower(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.TreeMap$Entry subCeiling(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.TreeMap$Entry subHigher(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.TreeMap$Entry subFloor(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.TreeMap$Entry subLower(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absCeiling(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absHigher(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absFloor(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absLower(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry subCeiling(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry subHigher(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry subFloor(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry subLower(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getEntry(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getEntryUsingComparator(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getCeilingEntry(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getFloorEntry(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getHigherEntry(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getLowerEntry(java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: java.lang.Object keyOrNull(lsp.test.jdk.util.TreeMap$Entry)> scored 9.9
<lsp.test.jdk.util.TreeMap: java.lang.Object key(lsp.test.jdk.util.TreeMap$Entry)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry buildFromSorted(int,int,int,int,java.util.Iterator,java.io.ObjectInputStream,java.lang.Object)> scored 9.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry successor(lsp.test.jdk.util.TreeMap$Entry)> scored 9.8
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry predecessor(lsp.test.jdk.util.TreeMap$Entry)> scored 9.8
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry parentOf(lsp.test.jdk.util.TreeMap$Entry)> scored 9.8
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry leftOf(lsp.test.jdk.util.TreeMap$Entry)> scored 9.8
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry rightOf(lsp.test.jdk.util.TreeMap$Entry)> scored 9.8
<lsp.test.jdk.util.Arrays: lsp.test.jdk.util.List asList(java.lang.Object[])> scored 9.75
<lsp.test.jdk.util.Arrays: void deepToString(java.lang.Object[],java.lang.StringBuilder,lsp.test.jdk.util.Set)> scored 9.75
<lsp.test.jdk.util.TreeMap$NavigableSubMap$EntrySetView: void <init>(lsp.test.jdk.util.TreeMap$NavigableSubMap)> scored 9.71
<lsp.test.jdk.util.Collections$CheckedRandomAccessList: void <init>(lsp.test.jdk.util.List,java.lang.Class)> scored 9.0
<lsp.test.jdk.util.Collections$SynchronizedRandomAccessList: void <init>(lsp.test.jdk.util.List,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$CheckedSortedMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$CheckedSortedMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$SynchronizedSet: void <init>(lsp.test.jdk.util.Set,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: int binarySearch(lsp.test.jdk.util.List,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: int indexedBinarySearch(lsp.test.jdk.util.List,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: int iteratorBinarySearch(lsp.test.jdk.util.List,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: void fill(lsp.test.jdk.util.List,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Set singleton(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.List singletonList(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.List nCopies(int,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Set newSetFromMap(lsp.test.jdk.util.Map)> scored 9.0
<lsp.test.jdk.util.Collections$CheckedList: void <init>(lsp.test.jdk.util.List,java.lang.Class)> scored 9.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: void <init>(lsp.test.jdk.util.SortedMap,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$SynchronizedList: void <init>(lsp.test.jdk.util.List,java.lang.Object)> scored 9.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$CheckedSet: void <init>(lsp.test.jdk.util.Set,java.lang.Class)> scored 9.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: java.lang.Object currentValue(lsp.test.jdk.util.List)> scored 9.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: void <init>(lsp.test.jdk.util.Set,java.lang.Class)> scored 9.0
<lsp.test.jdk.util.TreeMap$SubMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.TreeMap$SubMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.SortedMap: lsp.test.jdk.util.SortedMap headMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.SortedMap: lsp.test.jdk.util.SortedMap tailMap(java.lang.Object)> scored 9.0
<lsp.test.jdk.util.sql.PreparedStatement: void setTimestamp(int,lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Timestamp getTimestamp(int)> scored 8.96
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Timestamp getTimestamp(java.lang.String)> scored 8.96
<lsp.test.jdk.util.sql.ResultSet: void updateTimestamp(int,lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.ResultSet: void updateTimestamp(java.lang.String,lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Timestamp getTimestamp(int)> scored 8.96
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Timestamp getTimestamp(int,java.util.Calendar)> scored 8.96
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Timestamp getTimestamp(java.lang.String)> scored 8.96
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Timestamp getTimestamp(java.lang.String,java.util.Calendar)> scored 8.96
<lsp.test.jdk.util.sql.CallableStatement: void setTimestamp(java.lang.String,lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.CallableStatement: void setTimestamp(java.lang.String,lsp.test.jdk.util.sql.Timestamp,java.util.Calendar)> scored 8.96
<lsp.test.jdk.util.sql.SQLOutput: void writeTimestamp(lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.Timestamp readTimestamp()> scored 8.96
<lsp.test.jdk.util.sql.Timestamp: boolean after(lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.Timestamp: boolean before(lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.Timestamp: int compareTo(lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.Timestamp: boolean equals(lsp.test.jdk.util.sql.Timestamp)> scored 8.96
<lsp.test.jdk.util.sql.Timestamp: lsp.test.jdk.util.sql.Timestamp valueOf(java.lang.String)> scored 8.96
<lsp.test.jdk.util.DateFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition)> scored 8.8
<lsp.test.jdk.util.Format: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition)> scored 8.8
<lsp.test.jdk.util.NumberFormat: java.lang.StringBuffer format(java.lang.Object,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition)> scored 8.8
<lsp.test.jdk.util.SimpleDateFormat: lsp.test.jdk.util.AttributedCharacterIterator formatToCharacterIteratorImpl(lsp.test.jdk.util.Date)> scored 8.2
<lsp.test.jdk.util.SimpleDateFormat: lsp.test.jdk.util.Date parse(java.lang.String,lsp.test.jdk.util.ParsePosition)> scored 8.2
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.Date parse(java.lang.String,lsp.test.jdk.util.ParsePosition)> scored 8.2
<lsp.test.jdk.util.LinkedList: java.lang.Object remove(lsp.test.jdk.util.LinkedList$Entry)> scored 8.1
<lsp.test.jdk.util.AbstractMap$2$1: void <init>(lsp.test.jdk.util.AbstractMap$2)> scored 8.05
<lsp.test.jdk.util.AbstractMap$1$1: void <init>(lsp.test.jdk.util.AbstractMap$1)> scored 8.05
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.SortedSet headSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.SortedSet tailSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.NavigableMap headMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.NavigableMap tailMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.NavigableMap headMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.NavigableMap tailMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.Collections: void copy(lsp.test.jdk.util.List,lsp.test.jdk.util.List)> scored 8.0
<lsp.test.jdk.util.Collections: int indexOfSubList(lsp.test.jdk.util.List,lsp.test.jdk.util.List)> scored 8.0
<lsp.test.jdk.util.Collections: int lastIndexOfSubList(lsp.test.jdk.util.List,lsp.test.jdk.util.List)> scored 8.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Set unmodifiableSet(lsp.test.jdk.util.Set)> scored 8.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.List unmodifiableList(lsp.test.jdk.util.List)> scored 8.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.SortedMap unmodifiableSortedMap(lsp.test.jdk.util.SortedMap)> scored 8.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Set synchronizedSet(lsp.test.jdk.util.Set)> scored 8.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.List synchronizedList(lsp.test.jdk.util.List)> scored 8.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.SortedMap synchronizedSortedMap(lsp.test.jdk.util.SortedMap)> scored 8.0
<lsp.test.jdk.util.SortedSet: lsp.test.jdk.util.SortedSet headSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.SortedSet: lsp.test.jdk.util.SortedSet tailSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry: void <init>(lsp.test.jdk.util.Map$Entry,java.lang.Class)> scored 8.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.SortedSet headSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.SortedSet tailSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.Collections$CheckedSortedSet: void <init>(lsp.test.jdk.util.SortedSet,java.lang.Class)> scored 8.0
<lsp.test.jdk.util.Collections$CheckedSortedSet: lsp.test.jdk.util.SortedSet headSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.Collections$CheckedSortedSet: lsp.test.jdk.util.SortedSet tailSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedSet: lsp.test.jdk.util.SortedSet headSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedSet: lsp.test.jdk.util.SortedSet tailSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry ceilingEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry higherEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry floorEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry lowerEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry lowerEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry floorEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry ceilingEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry higherEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.NavigableMap headMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.NavigableMap tailMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.TreeMap: void addAllForTreeSet(lsp.test.jdk.util.SortedSet,java.lang.Object)> scored 8.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry lowerEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry floorEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry ceilingEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry higherEntry(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.NavigableMap headMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.NavigableMap tailMap(java.lang.Object,boolean)> scored 8.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: void <init>(lsp.test.jdk.util.SortedSet,java.lang.Object)> scored 8.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: lsp.test.jdk.util.SortedSet headSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: lsp.test.jdk.util.SortedSet tailSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.NavigableSet: lsp.test.jdk.util.SortedSet headSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.NavigableSet: lsp.test.jdk.util.SortedSet tailSet(java.lang.Object)> scored 8.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry exportEntry(lsp.test.jdk.util.TreeMap$Entry)> scored 7.9
<lsp.test.jdk.util.Arrays: void sort(java.lang.Object[],lsp.test.jdk.util.Comparator)> scored 7.75
<lsp.test.jdk.util.Arrays: void sort(java.lang.Object[],int,int,lsp.test.jdk.util.Comparator)> scored 7.75
<lsp.test.jdk.util.Collections$CheckedCollection$1: void <init>(lsp.test.jdk.util.Collections$CheckedCollection)> scored 7.725
<lsp.test.jdk.util.AttributedCharacterIterator: int getRunLimit(lsp.test.jdk.util.AttributedCharacterIterator$Attribute)> scored 7.699999999999999
<lsp.test.jdk.util.AttributedCharacterIterator: int getRunStart(lsp.test.jdk.util.AttributedCharacterIterator$Attribute)> scored 7.699999999999999
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getRunLimit(lsp.test.jdk.util.AttributedCharacterIterator$Attribute)> scored 7.699999999999999
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getRunStart(lsp.test.jdk.util.AttributedCharacterIterator$Attribute)> scored 7.699999999999999
<lsp.test.jdk.util.Collections$SingletonSet: java.lang.Object access$400(lsp.test.jdk.util.Collections$SingletonSet)> scored 7.5
<lsp.test.jdk.util.ULocale$IDParser: lsp.test.jdk.util.Map access$1300(lsp.test.jdk.util.ULocale$IDParser)> scored 7.5
<lsp.test.jdk.util.Observer: void update(lsp.test.jdk.util.Observable,java.lang.Object)> scored 7.4
<lsp.test.jdk.util.sql.SQLException: lsp.test.jdk.util.sql.SQLException getNextException()> scored 7.02
<lsp.test.jdk.util.sql.SQLException: void setNextException(lsp.test.jdk.util.sql.SQLException)> scored 7.02
<lsp.test.jdk.util.sql.SQLException$InternalIterator: void <init>(lsp.test.jdk.util.sql.SQLException)> scored 7.02
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.NavigableSet headSet(java.lang.Object,boolean)> scored 7.0
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.NavigableSet tailSet(java.lang.Object,boolean)> scored 7.0
<lsp.test.jdk.util.SimpleDateFormat: lsp.test.jdk.util.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)> scored 7.0
<lsp.test.jdk.util.SimpleDateFormat: java.lang.Object toICUField(lsp.test.jdk.util.Format$Field)> scored 7.0
<lsp.test.jdk.util.DateFormat: java.lang.Object parseObject(java.lang.String,lsp.test.jdk.util.ParsePosition)> scored 7.0
<lsp.test.jdk.util.Collections: java.lang.Object get(lsp.test.jdk.util.ListIterator,int)> scored 7.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Enumeration enumeration(lsp.test.jdk.util.Collection)> scored 7.0
<lsp.test.jdk.util.Format: lsp.test.jdk.util.AttributedCharacterIterator formatToCharacterIterator(java.lang.Object)> scored 7.0
<lsp.test.jdk.util.Format: java.lang.Object parseObject(java.lang.String,lsp.test.jdk.util.ParsePosition)> scored 7.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.NavigableSet headSet(java.lang.Object,boolean)> scored 7.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.NavigableSet tailSet(java.lang.Object,boolean)> scored 7.0
<lsp.test.jdk.util.NumberFormat: java.lang.Object parseObject(java.lang.String,lsp.test.jdk.util.ParsePosition)> scored 7.0
<lsp.test.jdk.util.NavigableSet: lsp.test.jdk.util.NavigableSet headSet(java.lang.Object,boolean)> scored 7.0
<lsp.test.jdk.util.NavigableSet: lsp.test.jdk.util.NavigableSet tailSet(java.lang.Object,boolean)> scored 7.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Array createArrayOf(java.lang.String,java.lang.Object[])> scored 6.75
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Struct createStruct(java.lang.String,java.lang.Object[])> scored 6.75
<lsp.test.jdk.util.ListResourceBundle: java.lang.Object[][] getContents()> scored 6.612499999999999
<lsp.test.jdk.util.LinkedHashMap: void transfer(lsp.test.jdk.util.HashMap$Entry[])> scored 6.4399999999999995
<lsp.test.jdk.util.HashMap: void transfer(lsp.test.jdk.util.HashMap$Entry[])> scored 6.4399999999999995
<lsp.test.jdk.util.Collator: lsp.test.jdk.util.Collator getInstance()> scored 6.4
<lsp.test.jdk.util.Collator: lsp.test.jdk.util.Collator getInstance(java.util.Locale)> scored 6.4
<lsp.test.jdk.util.SimpleDateFormat: lsp.test.jdk.util.Date get2DigitYearStart()> scored 6.2
<lsp.test.jdk.util.SimpleDateFormat: void set2DigitYearStart(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.DateFormat: java.lang.String format(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.DateFormat: lsp.test.jdk.util.Date parse(java.lang.String)> scored 6.2
<lsp.test.jdk.util.TimeZone: boolean inDaylightTime(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.GregorianCalendar: lsp.test.jdk.util.Date getGregorianChange()> scored 6.2
<lsp.test.jdk.util.GregorianCalendar: void setGregorianChange(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.Calendar: lsp.test.jdk.util.Date getTime()> scored 6.2
<lsp.test.jdk.util.Calendar: void setTime(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.SimpleTimeZone: boolean inDaylightTime(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.Date: boolean after(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.Date: boolean before(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.Date: int compareTo(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.sql.Timestamp: int compareTo(lsp.test.jdk.util.Date)> scored 6.2
<lsp.test.jdk.util.AttributedString: void <init>(lsp.test.jdk.util.AttributedCharacterIterator,int,int,lsp.test.jdk.util.Set)> scored 6.0
<lsp.test.jdk.util.Collections: void sort(lsp.test.jdk.util.List,lsp.test.jdk.util.Comparator)> scored 6.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.SortedSet unmodifiableSortedSet(lsp.test.jdk.util.SortedSet)> scored 6.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.SortedSet synchronizedSortedSet(lsp.test.jdk.util.SortedSet)> scored 6.0
<lsp.test.jdk.util.sql.Array: lsp.test.jdk.util.sql.ResultSet getResultSet(long,int,lsp.test.jdk.util.Map)> scored 6.0
<lsp.test.jdk.util.sql.Array: lsp.test.jdk.util.sql.ResultSet getResultSet(lsp.test.jdk.util.Map)> scored 6.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collections$UnmodifiableCollection: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.LinkedList: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collections$SynchronizedCollection: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collections: void swap(java.lang.Object[],int,int)> scored 5.75
<lsp.test.jdk.util.Collections$CheckedCollection: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collections$CheckedCollection: java.lang.Object[] zeroLengthElementArray()> scored 5.75
<lsp.test.jdk.util.Arrays: void sort(java.lang.Object[])> scored 5.75
<lsp.test.jdk.util.Arrays: void sort(java.lang.Object[],int,int)> scored 5.75
<lsp.test.jdk.util.Arrays: void swap(java.lang.Object[],int,int)> scored 5.75
<lsp.test.jdk.util.Arrays: int hashCode(java.lang.Object[])> scored 5.75
<lsp.test.jdk.util.Arrays: int deepHashCode(java.lang.Object[])> scored 5.75
<lsp.test.jdk.util.Arrays: java.lang.String toString(java.lang.Object[])> scored 5.75
<lsp.test.jdk.util.Arrays: java.lang.String deepToString(java.lang.Object[])> scored 5.75
<lsp.test.jdk.util.AbstractCollection: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.IdentityHashMap$EntrySet: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collections$SetFromMap: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.ArrayDeque: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collections$CheckedMap: java.lang.Object[] zeroLengthKeyArray()> scored 5.75
<lsp.test.jdk.util.Collections$CheckedMap: java.lang.Object[] zeroLengthValueArray()> scored 5.75
<lsp.test.jdk.util.Collections$CopiesList: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.PriorityQueue: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.EnumMap$EntrySet: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.sql.Struct: java.lang.Object[] getAttributes()> scored 5.75
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.ArrayList: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.ResourceBundle: java.lang.Class[] getClassContext()> scored 5.75
<lsp.test.jdk.util.List: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Arrays$ArrayList: void <init>(java.lang.Object[])> scored 5.75
<lsp.test.jdk.util.Arrays$ArrayList: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Set: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.Collection: java.lang.Object[] toArray()> scored 5.75
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.SQLWarning getWarnings()> scored 5.6080000000000005
<lsp.test.jdk.util.sql.Statement: lsp.test.jdk.util.sql.SQLWarning getWarnings()> scored 5.6080000000000005
<lsp.test.jdk.util.sql.SQLWarning: lsp.test.jdk.util.sql.SQLWarning getNextWarning()> scored 5.6080000000000005
<lsp.test.jdk.util.sql.SQLWarning: void setNextWarning(lsp.test.jdk.util.sql.SQLWarning)> scored 5.6080000000000005
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.SQLWarning getWarnings()> scored 5.6080000000000005
<lsp.test.jdk.util.HashMap$HashIterator: lsp.test.jdk.util.HashMap$Entry nextEntry()> scored 5.6
<lsp.test.jdk.util.Collections$CheckedList$1: void <init>(lsp.test.jdk.util.Collections$CheckedList,int)> scored 5.6000000000000005
<lsp.test.jdk.util.Collections$UnmodifiableList$1: void <init>(lsp.test.jdk.util.Collections$UnmodifiableList,int)> scored 5.6000000000000005
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.LinkedHashMap$EntryIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.HashMap$KeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$EntrySetView: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$EntrySetView: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$KeySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object first()> scored 5.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object last()> scored 5.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object pollFirst()> scored 5.0
<lsp.test.jdk.util.TreeMap$KeySet: java.lang.Object pollLast()> scored 5.0
<lsp.test.jdk.util.TreeMap$KeySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AttributedString: void <init>(java.lang.String,lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.AttributedString: void addAttributes(lsp.test.jdk.util.Map,int,int)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet$EnumSetIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.ULocale: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.ULocale: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ULocale: java.lang.Object getCLDRVersion()> scored 5.0
<lsp.test.jdk.util.HashMap$ValueIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.ServiceLoader: void <init>(java.lang.Class,java.lang.ClassLoader)> scored 5.0
<lsp.test.jdk.util.ServiceLoader: void fail(java.lang.Class,java.lang.String,java.lang.Throwable)> scored 5.0
<lsp.test.jdk.util.ServiceLoader: void fail(java.lang.Class,java.lang.String)> scored 5.0
<lsp.test.jdk.util.ServiceLoader: void fail(java.lang.Class,java.net.URL,int,java.lang.String)> scored 5.0
<lsp.test.jdk.util.ServiceLoader: int parseLine(java.lang.Class,java.net.URL,java.io.BufferedReader,int,java.util.List)> scored 5.0
<lsp.test.jdk.util.ServiceLoader: java.util.Iterator parse(java.lang.Class,java.net.URL)> scored 5.0
<lsp.test.jdk.util.ServiceLoader: void access$100(java.lang.Class,java.lang.String,java.lang.Throwable)> scored 5.0
<lsp.test.jdk.util.ServiceLoader: void access$400(java.lang.Class,java.lang.String)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$Values: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$Values: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collator$1: java.lang.Object run()> scored 5.0
<lsp.test.jdk.util.ResourceBundle$Control$1: java.lang.Object run()> scored 5.0
<lsp.test.jdk.util.AbstractMap$2$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.AbstractMap$1$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.AbstractSequentialList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.AbstractSequentialList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractSequentialList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.AbstractSequentialList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean offer(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.lang.Object poll()> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.lang.Object remove()> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.lang.Object peek()> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.lang.Object element()> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.BitSet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.BitSet: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Currency$1: java.lang.Object run()> scored 5.0
<lsp.test.jdk.util.JDKTest: int doWork(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AttributedCharacterIterator: lsp.test.jdk.util.Map getAttributes()> scored 5.0
<lsp.test.jdk.util.Collections$EmptySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$EmptySet: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.Collator: void <init>(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collator: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Collator: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedHashSet: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.sql.PreparedStatement: void setObject(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.PreparedStatement: void setObject(int,java.lang.Object,int)> scored 5.0
<lsp.test.jdk.util.sql.PreparedStatement: void setObject(int,java.lang.Object,int,int)> scored 5.0
<lsp.test.jdk.util.LinkedHashMap$KeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.UResourceBundle: java.lang.Object getVersion()> scored 5.0
<lsp.test.jdk.util.UResourceBundle: java.lang.Object getIterator()> scored 5.0
<lsp.test.jdk.util.UResourceBundle: java.lang.Object handleGetObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$ValueIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.AttributedString$Range: void <init>(int,int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedRandomAccessList: java.lang.Object writeReplace()> scored 5.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.Object getObject(int)> scored 5.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.Object getObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.sql.ResultSet: void updateObject(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.ResultSet: void updateObject(int,java.lang.Object,int)> scored 5.0
<lsp.test.jdk.util.sql.ResultSet: void updateObject(java.lang.String,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.ResultSet: void updateObject(java.lang.String,java.lang.Object,int)> scored 5.0
<lsp.test.jdk.util.LinkedHashMap$ValueIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.ServiceLoader$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Hashtable$EmptyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedSortedMap: java.lang.Object firstKey()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedSortedMap: java.lang.Object lastKey()> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$DescendingSubMapKeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList$1: java.lang.Object previous()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList$1: void set(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList$1: void add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashMap$EntryIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Hashtable$Entry: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Hashtable$Entry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.Hashtable$Entry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.Hashtable$Entry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SingletonSet$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$DescendingSubMapEntryIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.LinkedHashMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.LinkedHashMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$KeySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$KeySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$KeySet: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Queue: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Queue: boolean offer(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Queue: java.lang.Object remove()> scored 5.0
<lsp.test.jdk.util.Queue: java.lang.Object poll()> scored 5.0
<lsp.test.jdk.util.Queue: java.lang.Object element()> scored 5.0
<lsp.test.jdk.util.Queue: java.lang.Object peek()> scored 5.0
<lsp.test.jdk.util.EnumMap: void <init>(java.lang.Class)> scored 5.0
<lsp.test.jdk.util.EnumMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.EnumMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap: boolean isValidKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.EnumMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.EnumMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap: java.lang.Enum[] getKeyUniverse(java.lang.Class)> scored 5.0
<lsp.test.jdk.util.EnumMap: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.EnumMap: java.lang.Object access$1400()> scored 5.0
<lsp.test.jdk.util.IllegalFormatConversionException: void <init>(char,java.lang.Class)> scored 5.0
<lsp.test.jdk.util.IllegalFormatConversionException: java.lang.Class getArgumentClass()> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: int hash(java.lang.Object,int)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.IdentityHashMap: int access$400(java.lang.Object,int)> scored 5.0
<lsp.test.jdk.util.Locale: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Locale: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.LinkedList: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object getFirst()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object getLast()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object removeFirst()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object removeLast()> scored 5.0
<lsp.test.jdk.util.LinkedList: void addFirst(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: void addLast(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.LinkedList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.LinkedList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object peek()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object element()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object poll()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object remove()> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean offer(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean offerFirst(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean offerLast(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object peekFirst()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object peekLast()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object pollFirst()> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object pollLast()> scored 5.0
<lsp.test.jdk.util.LinkedList: void push(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object pop()> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean removeFirstOccurrence(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: boolean removeLastOccurrence(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.SimpleDateFormat: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.SimpleDateFormat: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AttributedCharacterIterator$Attribute: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AttributedCharacterIterator$Attribute: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.EventObject: void <init>(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EventObject: java.lang.Object getSource()> scored 5.0
<lsp.test.jdk.util.HashMap$KeySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashMap$KeySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableSet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue$Itr: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$SingletonSet: void <init>(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SingletonSet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.DateFormat: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.DateFormat: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractQueue: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractQueue: java.lang.Object remove()> scored 5.0
<lsp.test.jdk.util.AbstractQueue: java.lang.Object element()> scored 5.0
<lsp.test.jdk.util.AbstractQueue: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.ParsePosition: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumSet: void <init>(java.lang.Class,java.lang.Enum[])> scored 5.0
<lsp.test.jdk.util.EnumSet: java.lang.Enum[] getUniverse(java.lang.Class)> scored 5.0
<lsp.test.jdk.util.EnumSet: java.lang.Object writeReplace()> scored 5.0
<lsp.test.jdk.util.EnumSet: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Collections$EmptyMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$EmptyMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$EmptyMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.Collections$EmptyMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$EmptyMap: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.CharacterIterator: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedSet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Map emptyMap()> scored 5.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Queue asLifoQueue(lsp.test.jdk.util.Deque)> scored 5.0
<lsp.test.jdk.util.Hashtable$Enumerator: java.lang.Object nextElement()> scored 5.0
<lsp.test.jdk.util.Hashtable$Enumerator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.SortedSet: java.lang.Object first()> scored 5.0
<lsp.test.jdk.util.SortedSet: java.lang.Object last()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: java.lang.Object previous()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: void set(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: void add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TimeZone: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Format: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Format: java.lang.String format(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Format: java.lang.Object parseObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.TreeMap$EntrySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$EntrySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: void typeCheck(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Enumeration: java.lang.Object nextElement()> scored 5.0
<lsp.test.jdk.util.AbstractCollection: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractCollection: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractCollection: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractCollection: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.AbstractCollection: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.AbstractCollection: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.AbstractCollection: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.AbstractList: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.AbstractList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.AbstractList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractList: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.AbstractList: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.GregorianCalendar: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.GregorianCalendar: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ListResourceBundle: java.lang.Object handleGetObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.Collections$1: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$1: java.lang.Object nextElement()> scored 5.0
<lsp.test.jdk.util.LinkedList$ListItr: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.LinkedList$ListItr: java.lang.Object previous()> scored 5.0
<lsp.test.jdk.util.LinkedList$ListItr: void set(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList$ListItr: void add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ULocale$1ULocaleAcceptLanguageQ: int compareTo(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: void addFirst(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: void addLast(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: boolean offerFirst(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: boolean offerLast(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object removeFirst()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object removeLast()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object pollFirst()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object pollLast()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object getFirst()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object getLast()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object peekFirst()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object peekLast()> scored 5.0
<lsp.test.jdk.util.Deque: boolean removeFirstOccurrence(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: boolean removeLastOccurrence(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: boolean offer(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object remove()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object poll()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object element()> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object peek()> scored 5.0
<lsp.test.jdk.util.Deque: void push(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: java.lang.Object pop()> scored 5.0
<lsp.test.jdk.util.Deque: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Deque: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.AbstractMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.AbstractMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractMap: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.ServiceLoader$LazyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$EntrySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$EntrySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$EntrySet: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.AbstractMap$1: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$Values: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$Values: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Hashtable: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Hashtable: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Hashtable: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.Hashtable: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.SubList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.SubList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.SubList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.SubList: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.SubList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.ICUResourceBundle: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable$EmptyEnumerator: java.lang.Object nextElement()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$ReverseComparator: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: void <init>(java.lang.Class,java.lang.Enum[])> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.RegularEnumSet: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque$DescendingIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.TreeMap$Entry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.TreeMap$Entry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.TreeMap$Entry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Annotation: void <init>(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Annotation: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.TreeSet: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.TreeSet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeSet: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeSet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeSet: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.TreeSet: java.lang.Object first()> scored 5.0
<lsp.test.jdk.util.TreeSet: java.lang.Object last()> scored 5.0
<lsp.test.jdk.util.TreeSet: java.lang.Object pollFirst()> scored 5.0
<lsp.test.jdk.util.TreeSet: java.lang.Object pollLast()> scored 5.0
<lsp.test.jdk.util.TreeSet: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.ArrayDeque$DeqIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.Object getObject(int)> scored 5.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.Object getObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.sql.CallableStatement: void setObject(java.lang.String,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.CallableStatement: void setObject(java.lang.String,java.lang.Object,int)> scored 5.0
<lsp.test.jdk.util.sql.CallableStatement: void setObject(java.lang.String,java.lang.Object,int,int)> scored 5.0
<lsp.test.jdk.util.IdentityHashMap$KeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: void addFirst(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: void addLast(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean offerFirst(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean offerLast(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object removeFirst()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object removeLast()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object pollFirst()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object pollLast()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object getFirst()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object getLast()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object peekFirst()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object peekLast()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean removeFirstOccurrence(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean removeLastOccurrence(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean offer(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object remove()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object poll()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object element()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object peek()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: void push(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object pop()> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayDeque: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableList: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.sql.SQLXML: javax.xml.transform.Source getSource(java.lang.Class)> scored 5.0
<lsp.test.jdk.util.sql.SQLXML: javax.xml.transform.Result setResult(java.lang.Class)> scored 5.0
<lsp.test.jdk.util.EnumMap$ValueIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.TreeMap$KeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapKeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: java.lang.Object firstKey()> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: java.lang.Object lastKey()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedMap: java.lang.Object firstKey()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedMap: java.lang.Object lastKey()> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapEntryIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.sql.Wrapper: boolean isWrapperFor(java.lang.Class)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Observable: void notifyObservers(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.CollationKey: void <init>(java.lang.String,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.CollationKey: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.CollationKey: int compareTo(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedSortedSet: java.lang.Object first()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedSortedSet: java.lang.Object last()> scored 5.0
<lsp.test.jdk.util.Calendar: boolean after(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Calendar: boolean before(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Calendar: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Calendar: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Calendar: int compareTo(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ICUResourceBundle$1: java.lang.Object run()> scored 5.0
<lsp.test.jdk.util.NumberFormat$Field: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.Collections$CopiesList: void <init>(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CopiesList: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CopiesList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CopiesList: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CopiesList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void initFromCollection(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: boolean offer(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: java.lang.Object peek()> scored 5.0
<lsp.test.jdk.util.PriorityQueue: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: boolean removeEq(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: java.lang.Object poll()> scored 5.0
<lsp.test.jdk.util.PriorityQueue: java.lang.Object removeAt(int)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void siftUp(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void siftUpComparable(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void siftUpUsingComparator(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void siftDown(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void siftDownComparable(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.PriorityQueue: void siftDownUsingComparator(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.UUID: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.UUID: int compareTo(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$ValueIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.SimpleTimeZone: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.SimpleTimeZone: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Stack: java.lang.Object pop()> scored 5.0
<lsp.test.jdk.util.Stack: java.lang.Object peek()> scored 5.0
<lsp.test.jdk.util.Stack: int search(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Map$Entry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.Map$Entry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.Map$Entry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.SQLException$InternalIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedSet: java.lang.Object first()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedSet: java.lang.Object last()> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: boolean tooLow(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: boolean tooHigh(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: boolean inRange(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: boolean inClosedRange(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: boolean inRange(java.lang.Object,boolean)> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object firstKey()> scored 5.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.lang.Object lastKey()> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedList: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.TreeMap$EntryIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.Comparator: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Map: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Map: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Map: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Map: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.Map: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.NumberFormat: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.NumberFormat: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashSet: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.HashSet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashSet: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashSet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashSet: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.sql.SQLInput: java.lang.Object readObject()> scored 5.0
<lsp.test.jdk.util.Date: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.Date: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Date: int compareTo(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable$ValueCollection: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable$EntrySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable$EntrySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable$EntrySet: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractList$Itr: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.TreeMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.TreeMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap: java.lang.Object firstKey()> scored 5.0
<lsp.test.jdk.util.TreeMap: java.lang.Object lastKey()> scored 5.0
<lsp.test.jdk.util.TreeMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.TreeMap: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.TreeMap: void readTreeSet(int,java.io.ObjectInputStream,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap: void buildFromSorted(int,java.util.Iterator,java.io.ObjectInputStream,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap$EntrySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap$EntrySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$DescendingKeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.EnumMap$Values: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap$Values: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.BreakIterator: void <init>(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.BreakIterator: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.FieldPosition: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ULocale$IDParser: lsp.test.jdk.util.Map getKeywordMap()> scored 5.0
<lsp.test.jdk.util.AsciiUtil$CaseInsensitiveKey: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedSet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: lsp.test.jdk.util.Map getAttributes()> scored 5.0
<lsp.test.jdk.util.EnumMap$EntryIterator: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.EnumMap$EntryIterator: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap$EntryIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.EnumMap$EntryIterator: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.Collections$EmptyList: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$EmptyList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.Collections$EmptyList: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.Collections$SingletonMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SingletonMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SingletonMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.EnumMap$KeyIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.AbstractMap$2: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableRandomAccessList: java.lang.Object writeReplace()> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractSet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.AbstractSet: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: java.lang.Object first()> scored 5.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: java.lang.Object last()> scored 5.0
<lsp.test.jdk.util.Collections$SingletonList: void <init>(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SingletonList: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$SingletonList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.HashMap$EntrySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashMap$EntrySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.Map getTypeMap()> scored 5.0
<lsp.test.jdk.util.sql.Connection: void setTypeMap(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.ArrayList: void <init>(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.ArrayList: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayList: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayList: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.ArrayList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.ArrayList: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayList: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayList: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.ArrayList: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ArrayList: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.ArrayList: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.ResourceBundle: java.lang.Object getObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.ResourceBundle: java.lang.Object handleGetObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.Collections$EmptySet$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.UResourceBundle$ResourceCacheKey: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.UResourceBundle$ResourceCacheKey: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.List: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.List: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.List: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.List: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.List: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.List: boolean addAll(int,lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.List: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.List: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.List: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.List: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.List: void add(int,java.lang.Object)> scored 5.0
<lsp.test.jdk.util.List: java.lang.Object remove(int)> scored 5.0
<lsp.test.jdk.util.List: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.List: int lastIndexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Currency: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(lsp.test.jdk.util.Map,java.lang.Throwable)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(java.lang.String,lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(java.lang.String,lsp.test.jdk.util.Map,java.lang.Throwable)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(java.lang.String,java.lang.String,int,lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(java.lang.String,java.lang.String,int,lsp.test.jdk.util.Map,java.lang.Throwable)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(java.lang.String,java.lang.String,lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>(java.lang.String,java.lang.String,lsp.test.jdk.util.Map,java.lang.Throwable)> scored 5.0
<lsp.test.jdk.util.sql.SQLClientInfoException: lsp.test.jdk.util.Map getFailedProperties()> scored 5.0
<lsp.test.jdk.util.ResourceBundle$1: java.lang.Object handleGetObject(java.lang.String)> scored 5.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader: java.lang.Class loadClass(java.lang.String)> scored 5.0
<lsp.test.jdk.util.Arrays$ArrayList: java.lang.Object get(int)> scored 5.0
<lsp.test.jdk.util.Arrays$ArrayList: int indexOf(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Arrays$ArrayList: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.DateFormatSymbols: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.Timestamp: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.Timestamp: int compareTo(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collections$CheckedCollection$1: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.NavigableSet: java.lang.Object pollFirst()> scored 5.0
<lsp.test.jdk.util.NavigableSet: java.lang.Object pollLast()> scored 5.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashMap$Values: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap$KeySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.EnumMap$KeySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashMap: void <init>(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.HashMap: java.lang.Object getForNullKey()> scored 5.0
<lsp.test.jdk.util.HashMap: boolean containsKey(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashMap: void putAllForCreate(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.HashMap: void putAll(lsp.test.jdk.util.Map)> scored 5.0
<lsp.test.jdk.util.HashMap: boolean containsValue(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.HashMap: java.lang.Object clone()> scored 5.0
<lsp.test.jdk.util.HashMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.HashMap$Entry: java.lang.Object getKey()> scored 5.0
<lsp.test.jdk.util.HashMap$Entry: java.lang.Object getValue()> scored 5.0
<lsp.test.jdk.util.HashMap$Entry: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.Array: java.lang.Object getArray()> scored 5.0
<lsp.test.jdk.util.sql.Array: java.lang.Object getArray(long,int)> scored 5.0
<lsp.test.jdk.util.Hashtable$KeySet: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Hashtable$KeySet: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ListIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.ListIterator: java.lang.Object previous()> scored 5.0
<lsp.test.jdk.util.ListIterator: void set(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.ListIterator: void add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.LinkedList$DescendingIterator: java.lang.Object next()> scored 5.0
<lsp.test.jdk.util.EnumSet$SerializationProxy: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader$1: java.lang.Object run()> scored 5.0
<lsp.test.jdk.util.TreeMap$SubMap: java.lang.Object readResolve()> scored 5.0
<lsp.test.jdk.util.TreeMap$SubMap: java.lang.Object lastKey()> scored 5.0
<lsp.test.jdk.util.TreeMap$SubMap: java.lang.Object firstKey()> scored 5.0
<lsp.test.jdk.util.Properties: java.lang.Object setProperty(java.lang.String,java.lang.String)> scored 5.0
<lsp.test.jdk.util.Set: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Set: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Set: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Set: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Set: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Set: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Set: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Set: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.DriverManager: boolean isClassFromClassLoader(java.lang.Object,java.lang.ClassLoader)> scored 5.0
<lsp.test.jdk.util.Format$1: void <init>(java.lang.Object,java.lang.String)> scored 5.0
<lsp.test.jdk.util.Format$1: java.lang.Object run()> scored 5.0
<lsp.test.jdk.util.Collection: boolean contains(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collection: boolean add(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collection: boolean remove(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.Collection: boolean containsAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collection: boolean addAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collection: boolean removeAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collection: boolean retainAll(lsp.test.jdk.util.Collection)> scored 5.0
<lsp.test.jdk.util.Collection: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.sql.Ref: java.lang.Object getObject()> scored 5.0
<lsp.test.jdk.util.sql.Ref: void setObject(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.SortedMap: java.lang.Object firstKey()> scored 5.0
<lsp.test.jdk.util.SortedMap: java.lang.Object lastKey()> scored 5.0
<lsp.test.jdk.util.SortedMap: lsp.test.jdk.util.Collection values()> scored 5.0
<lsp.test.jdk.util.sql.RowId: boolean equals(java.lang.Object)> scored 5.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.TreeMap$Entry subLowest()> scored 4.9
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.TreeMap$Entry subHighest()> scored 4.9
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.TreeMap$Entry subLowest()> scored 4.9
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.TreeMap$Entry subHighest()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapIterator: lsp.test.jdk.util.TreeMap$Entry nextEntry()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapIterator: lsp.test.jdk.util.TreeMap$Entry prevEntry()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absLowest()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absHighest()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absHighFence()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry absLowFence()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry subLowest()> scored 4.9
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.TreeMap$Entry subHighest()> scored 4.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getFirstEntry()> scored 4.9
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.TreeMap$Entry getLastEntry()> scored 4.9
<lsp.test.jdk.util.TreeMap: boolean colorOf(lsp.test.jdk.util.TreeMap$Entry)> scored 4.9
<lsp.test.jdk.util.TreeMap: void setColor(lsp.test.jdk.util.TreeMap$Entry,boolean)> scored 4.9
<lsp.test.jdk.util.TreeMap: void rotateLeft(lsp.test.jdk.util.TreeMap$Entry)> scored 4.9
<lsp.test.jdk.util.TreeMap: void rotateRight(lsp.test.jdk.util.TreeMap$Entry)> scored 4.9
<lsp.test.jdk.util.TreeMap: void fixAfterInsertion(lsp.test.jdk.util.TreeMap$Entry)> scored 4.9
<lsp.test.jdk.util.TreeMap: void deleteEntry(lsp.test.jdk.util.TreeMap$Entry)> scored 4.9
<lsp.test.jdk.util.TreeMap: void fixAfterDeletion(lsp.test.jdk.util.TreeMap$Entry)> scored 4.9
<lsp.test.jdk.util.TreeMap$PrivateEntryIterator: lsp.test.jdk.util.TreeMap$Entry nextEntry()> scored 4.9
<lsp.test.jdk.util.TreeMap$PrivateEntryIterator: lsp.test.jdk.util.TreeMap$Entry prevEntry()> scored 4.9
<lsp.test.jdk.util.sql.RowIdLifetime: lsp.test.jdk.util.sql.RowIdLifetime[] values()> scored 4.678602499999999
<lsp.test.jdk.util.Collections$UnmodifiableCollection$1: void <init>(lsp.test.jdk.util.Collections$UnmodifiableCollection)> scored 4.5
<lsp.test.jdk.util.BitSet: lsp.test.jdk.util.BitSet get(int,int)> scored 4.2
<lsp.test.jdk.util.BitSet: boolean intersects(lsp.test.jdk.util.BitSet)> scored 4.2
<lsp.test.jdk.util.BitSet: void and(lsp.test.jdk.util.BitSet)> scored 4.2
<lsp.test.jdk.util.BitSet: void or(lsp.test.jdk.util.BitSet)> scored 4.2
<lsp.test.jdk.util.BitSet: void xor(lsp.test.jdk.util.BitSet)> scored 4.2
<lsp.test.jdk.util.BitSet: void andNot(lsp.test.jdk.util.BitSet)> scored 4.2
<lsp.test.jdk.util.Collator: lsp.test.jdk.util.CollationKey getCollationKey(java.lang.String)> scored 4.2
<lsp.test.jdk.util.CollationKey: int compareTo(lsp.test.jdk.util.CollationKey)> scored 4.2
<lsp.test.jdk.util.sql.ClientInfoStatus: lsp.test.jdk.util.sql.ClientInfoStatus[] values()> scored 4.1852525
<lsp.test.jdk.util.sql.RowIdLifetime: lsp.test.jdk.util.sql.RowIdLifetime valueOf(java.lang.String)> scored 4.06835
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.RowIdLifetime getRowIdLifetime()> scored 4.06835
<lsp.test.jdk.util.Collections$CheckedRandomAccessList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.AttributedCharacterIterator: lsp.test.jdk.util.Set getAllAttributeKeys()> scored 4.0
<lsp.test.jdk.util.AttributedCharacterIterator: int getRunLimit(lsp.test.jdk.util.Set)> scored 4.0
<lsp.test.jdk.util.AttributedCharacterIterator: int getRunStart(lsp.test.jdk.util.Set)> scored 4.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.ResourceBundle$NoFallbackControl: void <init>(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedRandomAccessList: void <init>(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedRandomAccessList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.ResourceBundle$Control: lsp.test.jdk.util.List getFormats(java.lang.String)> scored 4.0
<lsp.test.jdk.util.EnumMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.EnumMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.IdentityHashMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.IdentityHashMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableSet: void <init>(lsp.test.jdk.util.Set)> scored 4.0
<lsp.test.jdk.util.Collections$EmptyMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Collections$EmptyMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedSet: void <init>(lsp.test.jdk.util.Set)> scored 4.0
<lsp.test.jdk.util.Collections: void sort(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections: void reverse(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections: void shuffle(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections: void shuffle(lsp.test.jdk.util.List,java.util.Random)> scored 4.0
<lsp.test.jdk.util.Collections: void swap(lsp.test.jdk.util.List,int,int)> scored 4.0
<lsp.test.jdk.util.Collections: void rotate(lsp.test.jdk.util.List,int)> scored 4.0
<lsp.test.jdk.util.Collections: void rotate1(lsp.test.jdk.util.List,int)> scored 4.0
<lsp.test.jdk.util.Collections: void rotate2(lsp.test.jdk.util.List,int)> scored 4.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Set emptySet()> scored 4.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.List emptyList()> scored 4.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Comparator reverseOrder(lsp.test.jdk.util.Comparator)> scored 4.0
<lsp.test.jdk.util.AbstractList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.ListResourceBundle: lsp.test.jdk.util.Set handleKeySet()> scored 4.0
<lsp.test.jdk.util.AbstractMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.AbstractMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.Hashtable: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Hashtable: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.SubList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set getAvailableLocaleNameSet(java.lang.String)> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set getFullLocaleNameSet()> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set getFullLocaleNameSet(java.lang.String)> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set getAvailableLocaleNameSet()> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set createFullLocaleNameSet(java.lang.String)> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set createLocaleNameSet(java.lang.String)> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set access$200(java.lang.String)> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle: lsp.test.jdk.util.Set access$300(java.lang.String)> scored 4.0
<lsp.test.jdk.util.Collections$CheckedList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableList: void <init>(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: void <init>(lsp.test.jdk.util.SortedMap)> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedMap: void <init>(lsp.test.jdk.util.SortedMap)> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle$AvailEntry: lsp.test.jdk.util.Set getLocaleNameSet()> scored 4.0
<lsp.test.jdk.util.ICUResourceBundle$AvailEntry: lsp.test.jdk.util.Set getFullLocaleNameSet()> scored 4.0
<lsp.test.jdk.util.Collections$CheckedMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Collections$CheckedMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.ResourceBundle$SingleFormatControl: void <init>(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.ResourceBundle$SingleFormatControl: lsp.test.jdk.util.List getFormats(java.lang.String)> scored 4.0
<lsp.test.jdk.util.Collections$CopiesList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedList: void <init>(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.Map: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Map: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.TreeMap: void <init>(lsp.test.jdk.util.SortedMap)> scored 4.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet: void <init>(lsp.test.jdk.util.Set)> scored 4.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: boolean inRange(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: lsp.test.jdk.util.Set getAllAttributeKeys()> scored 4.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int runLimit(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getRunLimit(lsp.test.jdk.util.Set)> scored 4.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int runStart(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getRunStart(lsp.test.jdk.util.Set)> scored 4.0
<lsp.test.jdk.util.Collections$SingletonMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Collections$SingletonMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableRandomAccessList: void <init>(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableRandomAccessList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Collections$SynchronizedMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.ResourceBundle: boolean checkList(lsp.test.jdk.util.List)> scored 4.0
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.Set handleKeySet()> scored 4.0
<lsp.test.jdk.util.List: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.HashMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.HashMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.HashMap: lsp.test.jdk.util.Set entrySet0()> scored 4.0
<lsp.test.jdk.util.TreeMap$SubMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.Properties: lsp.test.jdk.util.Set stringPropertyNames()> scored 4.0
<lsp.test.jdk.util.RandomAccessSubList: lsp.test.jdk.util.List subList(int,int)> scored 4.0
<lsp.test.jdk.util.SortedMap: lsp.test.jdk.util.Set keySet()> scored 4.0
<lsp.test.jdk.util.SortedMap: lsp.test.jdk.util.Set entrySet()> scored 4.0
<lsp.test.jdk.util.SimpleDateFormat: void append(java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition,java.util.Vector,char,int)> scored 3.8000000000000003
<lsp.test.jdk.util.UUID: lsp.test.jdk.util.UUID randomUUID()> scored 3.8000000000000003
<lsp.test.jdk.util.UUID: lsp.test.jdk.util.UUID nameUUIDFromBytes(byte[])> scored 3.8000000000000003
<lsp.test.jdk.util.UUID: lsp.test.jdk.util.UUID fromString(java.lang.String)> scored 3.8000000000000003
<lsp.test.jdk.util.UUID: int compareTo(lsp.test.jdk.util.UUID)> scored 3.8000000000000003
<lsp.test.jdk.util.NumberFormat: java.lang.StringBuffer format(double,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition)> scored 3.8000000000000003
<lsp.test.jdk.util.NumberFormat: java.lang.StringBuffer format(long,java.lang.StringBuffer,lsp.test.jdk.util.FieldPosition)> scored 3.8000000000000003
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$1: void <init>(lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet)> scored 3.6999999999999997
<lsp.test.jdk.util.sql.ClientInfoStatus: lsp.test.jdk.util.sql.ClientInfoStatus valueOf(java.lang.String)> scored 3.6393500000000003
<lsp.test.jdk.util.NumberFormat: lsp.test.jdk.util.Currency getCurrency()> scored 3.5600000000000005
<lsp.test.jdk.util.NumberFormat: void setCurrency(lsp.test.jdk.util.Currency)> scored 3.5600000000000005
<lsp.test.jdk.util.Currency: lsp.test.jdk.util.Currency getInstance(java.lang.String)> scored 3.5600000000000005
<lsp.test.jdk.util.Currency: lsp.test.jdk.util.Currency getInstance(java.lang.String,int)> scored 3.5600000000000005
<lsp.test.jdk.util.Currency: lsp.test.jdk.util.Currency getInstance(java.util.Locale)> scored 3.5600000000000005
<lsp.test.jdk.util.LinkedHashMap$Entry: void access$600(lsp.test.jdk.util.LinkedHashMap$Entry,lsp.test.jdk.util.LinkedHashMap$Entry)> scored 3.2
<lsp.test.jdk.util.LinkedList: lsp.test.jdk.util.LinkedList$Entry entry(int)> scored 3.1
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$1: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.LinkedHashMap$EntryIterator: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.TreeMap$KeySet: void <init>(lsp.test.jdk.util.NavigableMap)> scored 3.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: void <init>(lsp.test.jdk.util.Map$Entry)> scored 3.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.NavigableMap descendingMap()> scored 3.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Statement getStatement()> scored 3.0
<lsp.test.jdk.util.HashMap$EntryIterator: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.NavigableMap descendingMap()> scored 3.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$DescendingSubMapEntryIterator: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.LinkedHashMap: boolean removeEldestEntry(lsp.test.jdk.util.Map$Entry)> scored 3.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.TreeSet: void <init>(lsp.test.jdk.util.NavigableMap)> scored 3.0
<lsp.test.jdk.util.TreeSet: void <init>(lsp.test.jdk.util.SortedSet)> scored 3.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry: void <init>(lsp.test.jdk.util.Map$Entry)> scored 3.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapEntryIterator: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.PriorityQueue: void <init>(lsp.test.jdk.util.SortedSet)> scored 3.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedSet: void <init>(lsp.test.jdk.util.SortedSet)> scored 3.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry firstEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry lastEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry pollFirstEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.Map$Entry pollLastEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap$EntryIterator: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.Hashtable$EntrySet: boolean add(lsp.test.jdk.util.Map$Entry)> scored 3.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry firstEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry lastEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry pollFirstEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Map$Entry pollLastEntry()> scored 3.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.NavigableMap descendingMap()> scored 3.0
<lsp.test.jdk.util.BreakIterator: lsp.test.jdk.util.CharacterIterator getText()> scored 3.0
<lsp.test.jdk.util.BreakIterator: void setText(lsp.test.jdk.util.CharacterIterator)> scored 3.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry firstEntry()> scored 3.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry lastEntry()> scored 3.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry pollFirstEntry()> scored 3.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.Map$Entry pollLastEntry()> scored 3.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.NavigableMap descendingMap()> scored 3.0
<lsp.test.jdk.util.EnumMap$EntryIterator: lsp.test.jdk.util.Map$Entry next()> scored 3.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: void <init>(lsp.test.jdk.util.SortedSet)> scored 3.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Statement createStatement()> scored 3.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Statement createStatement(int,int)> scored 3.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Statement createStatement(int,int,int)> scored 3.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean add(lsp.test.jdk.util.Map$Entry)> scored 3.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: void <init>(lsp.test.jdk.util.Map$Entry)> scored 3.0
<lsp.test.jdk.util.ULocale$IDParser$1: void <init>(lsp.test.jdk.util.ULocale$IDParser)> scored 2.5
<lsp.test.jdk.util.Collections$EmptySet: void <init>(lsp.test.jdk.util.Collections$1)> scored 2.5
<lsp.test.jdk.util.Collections$SingletonSet$1: void <init>(lsp.test.jdk.util.Collections$SingletonSet)> scored 2.5
<lsp.test.jdk.util.Collections$EmptyMap: void <init>(lsp.test.jdk.util.Collections$1)> scored 2.5
<lsp.test.jdk.util.Collections$ReverseComparator: void <init>(lsp.test.jdk.util.Collections$1)> scored 2.5
<lsp.test.jdk.util.AttributedString$AttributedIterator: boolean inRange(lsp.test.jdk.util.AttributedString$Range)> scored 2.5
<lsp.test.jdk.util.Collections$EmptyList: void <init>(lsp.test.jdk.util.Collections$1)> scored 2.5
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.TreeMap$KeySet: lsp.test.jdk.util.NavigableSet descendingSet()> scored 2.0
<lsp.test.jdk.util.AttributedString: void <init>(lsp.test.jdk.util.AttributedCharacterIterator)> scored 2.0
<lsp.test.jdk.util.AttributedString: void <init>(lsp.test.jdk.util.AttributedCharacterIterator,int,int)> scored 2.0
<lsp.test.jdk.util.AttributedString: lsp.test.jdk.util.AttributedCharacterIterator getIterator()> scored 2.0
<lsp.test.jdk.util.AbstractSequentialList: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: void <init>(lsp.test.jdk.util.Deque)> scored 2.0
<lsp.test.jdk.util.sql.PreparedStatement: void setClob(int,lsp.test.jdk.util.sql.Clob)> scored 2.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.Enumeration getKeys()> scored 2.0
<lsp.test.jdk.util.UResourceBundle: lsp.test.jdk.util.Enumeration handleGetKeys()> scored 2.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Clob getClob(int)> scored 2.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Clob getClob(java.lang.String)> scored 2.0
<lsp.test.jdk.util.sql.ResultSet: void updateClob(int,lsp.test.jdk.util.sql.Clob)> scored 2.0
<lsp.test.jdk.util.sql.ResultSet: void updateClob(java.lang.String,lsp.test.jdk.util.sql.Clob)> scored 2.0
<lsp.test.jdk.util.Collections$CheckedSortedMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.LinkedList: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.Collections: lsp.test.jdk.util.Comparator reverseOrder()> scored 2.0
<lsp.test.jdk.util.SortedSet: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.Format: boolean upTo(java.lang.String,lsp.test.jdk.util.ParsePosition,java.lang.StringBuffer,char)> scored 2.0
<lsp.test.jdk.util.Format: boolean upToWithQuotes(java.lang.String,lsp.test.jdk.util.ParsePosition,java.lang.StringBuffer,char,char)> scored 2.0
<lsp.test.jdk.util.AbstractList: lsp.test.jdk.util.ListIterator listIterator()> scored 2.0
<lsp.test.jdk.util.AbstractList: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.ListResourceBundle: lsp.test.jdk.util.Enumeration getKeys()> scored 2.0
<lsp.test.jdk.util.Hashtable: lsp.test.jdk.util.Enumeration keys()> scored 2.0
<lsp.test.jdk.util.Hashtable: lsp.test.jdk.util.Enumeration elements()> scored 2.0
<lsp.test.jdk.util.Hashtable: lsp.test.jdk.util.Enumeration getEnumeration(int)> scored 2.0
<lsp.test.jdk.util.SubList: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.Collections$CheckedList: lsp.test.jdk.util.ListIterator listIterator()> scored 2.0
<lsp.test.jdk.util.Collections$CheckedList: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.TreeSet: void <init>(lsp.test.jdk.util.Comparator)> scored 2.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.NavigableSet descendingSet()> scored 2.0
<lsp.test.jdk.util.TreeSet: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Clob getClob(int)> scored 2.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Clob getClob(java.lang.String)> scored 2.0
<lsp.test.jdk.util.sql.CallableStatement: void setClob(java.lang.String,lsp.test.jdk.util.sql.Clob)> scored 2.0
<lsp.test.jdk.util.Collections$UnmodifiableList: lsp.test.jdk.util.ListIterator listIterator()> scored 2.0
<lsp.test.jdk.util.Collections$UnmodifiableList: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.Collections$SynchronizedSortedMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.Collections$CheckedSortedSet: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.PriorityQueue: void <init>(int,lsp.test.jdk.util.Comparator)> scored 2.0
<lsp.test.jdk.util.PriorityQueue: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.sql.SQLOutput: void writeClob(lsp.test.jdk.util.sql.Clob)> scored 2.0
<lsp.test.jdk.util.Collections$UnmodifiableSortedSet: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.NavigableSet navigableKeySet()> scored 2.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: lsp.test.jdk.util.NavigableSet descendingKeySet()> scored 2.0
<lsp.test.jdk.util.Collections$SynchronizedList: lsp.test.jdk.util.ListIterator listIterator()> scored 2.0
<lsp.test.jdk.util.Collections$SynchronizedList: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.NumberFormat: java.lang.Number parse(java.lang.String,lsp.test.jdk.util.ParsePosition)> scored 2.0
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.Clob readClob()> scored 2.0
<lsp.test.jdk.util.TreeMap: void <init>(lsp.test.jdk.util.Comparator)> scored 2.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.NavigableSet navigableKeySet()> scored 2.0
<lsp.test.jdk.util.TreeMap: lsp.test.jdk.util.NavigableSet descendingKeySet()> scored 2.0
<lsp.test.jdk.util.FieldPosition: void <init>(lsp.test.jdk.util.Format$Field)> scored 2.0
<lsp.test.jdk.util.FieldPosition: void <init>(lsp.test.jdk.util.Format$Field,int)> scored 2.0
<lsp.test.jdk.util.FieldPosition: lsp.test.jdk.util.Format$Field getFieldAttribute()> scored 2.0
<lsp.test.jdk.util.ULocale$IDParser: lsp.test.jdk.util.Comparator getKeyComparator()> scored 2.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.NavigableSet navigableKeySet()> scored 2.0
<lsp.test.jdk.util.NavigableMap: lsp.test.jdk.util.NavigableSet descendingKeySet()> scored 2.0
<lsp.test.jdk.util.sql.Clob: long position(lsp.test.jdk.util.sql.Clob,long)> scored 2.0
<lsp.test.jdk.util.Collections$ReverseComparator2: void <init>(lsp.test.jdk.util.Comparator)> scored 2.0
<lsp.test.jdk.util.Collections$SynchronizedSortedSet: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.PreparedStatement prepareStatement(java.lang.String)> scored 2.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.PreparedStatement prepareStatement(java.lang.String,int)> scored 2.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.PreparedStatement prepareStatement(java.lang.String,int[])> scored 2.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.PreparedStatement prepareStatement(java.lang.String,int,int)> scored 2.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.PreparedStatement prepareStatement(java.lang.String,int,int,int)> scored 2.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.PreparedStatement prepareStatement(java.lang.String,java.lang.String[])> scored 2.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Clob createClob()> scored 2.0
<lsp.test.jdk.util.ResourceBundle: lsp.test.jdk.util.Enumeration getKeys()> scored 2.0
<lsp.test.jdk.util.List: lsp.test.jdk.util.ListIterator listIterator()> scored 2.0
<lsp.test.jdk.util.List: lsp.test.jdk.util.ListIterator listIterator(int)> scored 2.0
<lsp.test.jdk.util.ResourceBundle$1: lsp.test.jdk.util.Enumeration getKeys()> scored 2.0
<lsp.test.jdk.util.Dictionary: lsp.test.jdk.util.Enumeration keys()> scored 2.0
<lsp.test.jdk.util.Dictionary: lsp.test.jdk.util.Enumeration elements()> scored 2.0
<lsp.test.jdk.util.NavigableSet: lsp.test.jdk.util.NavigableSet descendingSet()> scored 2.0
<lsp.test.jdk.util.EventListenerProxy: void <init>(lsp.test.jdk.util.EventListener)> scored 2.0
<lsp.test.jdk.util.EventListenerProxy: lsp.test.jdk.util.EventListener getListener()> scored 2.0
<lsp.test.jdk.util.TreeMap$SubMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.Properties: lsp.test.jdk.util.Enumeration propertyNames()> scored 2.0
<lsp.test.jdk.util.sql.DriverManager: lsp.test.jdk.util.Enumeration getDrivers()> scored 2.0
<lsp.test.jdk.util.SortedMap: lsp.test.jdk.util.Comparator comparator()> scored 2.0
<lsp.test.jdk.util.sql.PreparedStatement: void setDate(int,lsp.test.jdk.util.sql.Date)> scored 1.6
<lsp.test.jdk.util.sql.PreparedStatement: void setTime(int,lsp.test.jdk.util.sql.Time)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Date getDate(int)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Date getDate(java.lang.String)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Time getTime(int)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Time getTime(java.lang.String)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: void updateDate(int,lsp.test.jdk.util.sql.Date)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: void updateDate(java.lang.String,lsp.test.jdk.util.sql.Date)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: void updateTime(int,lsp.test.jdk.util.sql.Time)> scored 1.6
<lsp.test.jdk.util.sql.ResultSet: void updateTime(java.lang.String,lsp.test.jdk.util.sql.Time)> scored 1.6
<lsp.test.jdk.util.TreeMap$DescendingSubMap$DescendingEntrySetView: void <init>(lsp.test.jdk.util.TreeMap$DescendingSubMap)> scored 1.6
<lsp.test.jdk.util.sql.Date: lsp.test.jdk.util.sql.Date valueOf(java.lang.String)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Date getDate(int)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Date getDate(int,java.util.Calendar)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Date getDate(java.lang.String)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Date getDate(java.lang.String,java.util.Calendar)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Time getTime(int)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Time getTime(int,java.util.Calendar)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Time getTime(java.lang.String)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Time getTime(java.lang.String,java.util.Calendar)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: void setDate(java.lang.String,lsp.test.jdk.util.sql.Date)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: void setDate(java.lang.String,lsp.test.jdk.util.sql.Date,java.util.Calendar)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: void setTime(java.lang.String,lsp.test.jdk.util.sql.Time)> scored 1.6
<lsp.test.jdk.util.sql.CallableStatement: void setTime(java.lang.String,lsp.test.jdk.util.sql.Time,java.util.Calendar)> scored 1.6
<lsp.test.jdk.util.LinkedHashMap$LinkedHashIterator: lsp.test.jdk.util.LinkedHashMap$Entry nextEntry()> scored 1.6
<lsp.test.jdk.util.sql.SQLOutput: void writeDate(lsp.test.jdk.util.sql.Date)> scored 1.6
<lsp.test.jdk.util.sql.SQLOutput: void writeTime(lsp.test.jdk.util.sql.Time)> scored 1.6
<lsp.test.jdk.util.sql.Time: lsp.test.jdk.util.sql.Time valueOf(java.lang.String)> scored 1.6
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.Date readDate()> scored 1.6
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.Time readTime()> scored 1.6
<lsp.test.jdk.util.LinkedHashMap$Entry: void addBefore(lsp.test.jdk.util.LinkedHashMap$Entry)> scored 1.6
<lsp.test.jdk.util.ResourceBundle$RBClassLoader: lsp.test.jdk.util.ResourceBundle$RBClassLoader access$000()> scored 1.3
<lsp.test.jdk.util.ResourceBundle$RBClassLoader$1: lsp.test.jdk.util.ResourceBundle$RBClassLoader run()> scored 1.3
<lsp.test.jdk.util.Properties: void load0(lsp.test.jdk.util.Properties$LineReader)> scored 1.3
<lsp.test.jdk.util.RegularEnumSet$EnumSetIterator: void <init>(lsp.test.jdk.util.RegularEnumSet)> scored 1.0
<lsp.test.jdk.util.XMLUtils$Resolver: void <init>(lsp.test.jdk.util.XMLUtils$1)> scored 1.0
<lsp.test.jdk.util.ULocale$Type: void <init>(lsp.test.jdk.util.ULocale$1)> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: lsp.test.jdk.util.sql.ResultSet executeQuery()> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: lsp.test.jdk.util.sql.ResultSetMetaData getMetaData()> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: lsp.test.jdk.util.sql.ParameterMetaData getParameterMetaData()> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: void setArray(int,lsp.test.jdk.util.sql.Array)> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBlob(int,lsp.test.jdk.util.sql.Blob)> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: void setRef(int,lsp.test.jdk.util.sql.Ref)> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: void setRowId(int,lsp.test.jdk.util.sql.RowId)> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNClob(int,lsp.test.jdk.util.sql.NClob)> scored 1.0
<lsp.test.jdk.util.sql.PreparedStatement: void setSQLXML(int,lsp.test.jdk.util.sql.SQLXML)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Array getArray(int)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Array getArray(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Blob getBlob(int)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Blob getBlob(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.ResultSetMetaData getMetaData()> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Ref getRef(int)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.Ref getRef(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateArray(int,lsp.test.jdk.util.sql.Array)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateArray(java.lang.String,lsp.test.jdk.util.sql.Array)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateBlob(int,lsp.test.jdk.util.sql.Blob)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateBlob(java.lang.String,lsp.test.jdk.util.sql.Blob)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateRef(int,lsp.test.jdk.util.sql.Ref)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateRef(java.lang.String,lsp.test.jdk.util.sql.Ref)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.RowId getRowId(int)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.RowId getRowId(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateRowId(int,lsp.test.jdk.util.sql.RowId)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateRowId(java.lang.String,lsp.test.jdk.util.sql.RowId)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateNClob(int,lsp.test.jdk.util.sql.NClob)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateNClob(java.lang.String,lsp.test.jdk.util.sql.NClob)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.NClob getNClob(int)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.NClob getNClob(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.SQLXML getSQLXML(int)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: lsp.test.jdk.util.sql.SQLXML getSQLXML(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateSQLXML(int,lsp.test.jdk.util.sql.SQLXML)> scored 1.0
<lsp.test.jdk.util.sql.ResultSet: void updateSQLXML(java.lang.String,lsp.test.jdk.util.sql.SQLXML)> scored 1.0
<lsp.test.jdk.util.sql.Blob: long position(lsp.test.jdk.util.sql.Blob,long)> scored 1.0
<lsp.test.jdk.util.sql.SQLData: void readSQL(lsp.test.jdk.util.sql.SQLInput,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.SQLData: void writeSQL(lsp.test.jdk.util.sql.SQLOutput)> scored 1.0
<lsp.test.jdk.util.sql.Statement: lsp.test.jdk.util.sql.ResultSet executeQuery(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.Statement: lsp.test.jdk.util.sql.Connection getConnection()> scored 1.0
<lsp.test.jdk.util.sql.Statement: lsp.test.jdk.util.sql.ResultSet getGeneratedKeys()> scored 1.0
<lsp.test.jdk.util.sql.Statement: lsp.test.jdk.util.sql.ResultSet getResultSet()> scored 1.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1: void <init>(lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet)> scored 1.0
<lsp.test.jdk.util.RegularEnumSet: long access$000(lsp.test.jdk.util.RegularEnumSet)> scored 1.0
<lsp.test.jdk.util.RegularEnumSet: long access$022(lsp.test.jdk.util.RegularEnumSet,long)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Array getArray(int)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Array getArray(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Blob getBlob(int)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Blob getBlob(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Ref getRef(int)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.Ref getRef(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.RowId getRowId(int)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.RowId getRowId(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: void setRowId(java.lang.String,lsp.test.jdk.util.sql.RowId)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: void setNClob(java.lang.String,lsp.test.jdk.util.sql.NClob)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.NClob getNClob(int)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.NClob getNClob(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: void setSQLXML(java.lang.String,lsp.test.jdk.util.sql.SQLXML)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.SQLXML getSQLXML(int)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: lsp.test.jdk.util.sql.SQLXML getSQLXML(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.CallableStatement: void setBlob(java.lang.String,lsp.test.jdk.util.sql.Blob)> scored 1.0
<lsp.test.jdk.util.Observable: void addObserver(lsp.test.jdk.util.Observer)> scored 1.0
<lsp.test.jdk.util.Observable: void deleteObserver(lsp.test.jdk.util.Observer)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeObject(lsp.test.jdk.util.sql.SQLData)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeRef(lsp.test.jdk.util.sql.Ref)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeBlob(lsp.test.jdk.util.sql.Blob)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeStruct(lsp.test.jdk.util.sql.Struct)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeArray(lsp.test.jdk.util.sql.Array)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeNClob(lsp.test.jdk.util.sql.NClob)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeRowId(lsp.test.jdk.util.sql.RowId)> scored 1.0
<lsp.test.jdk.util.sql.SQLOutput: void writeSQLXML(lsp.test.jdk.util.sql.SQLXML)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getAttributes(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getBestRowIdentifier(java.lang.String,java.lang.String,java.lang.String,int,boolean)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getCatalogs()> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getColumnPrivileges(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.Connection getConnection()> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getCrossReference(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getExportedKeys(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getImportedKeys(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getIndexInfo(java.lang.String,java.lang.String,java.lang.String,boolean,boolean)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getPrimaryKeys(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getProcedureColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getProcedures(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getSchemas()> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getSuperTables(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getSuperTypes(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getTablePrivileges(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getTables(java.lang.String,java.lang.String,java.lang.String,java.lang.String[])> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getTableTypes()> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getTypeInfo()> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getUDTs(java.lang.String,java.lang.String,java.lang.String,int[])> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getVersionColumns(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getSchemas(java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getClientInfoProperties()> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getFunctions(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DatabaseMetaData: lsp.test.jdk.util.sql.ResultSet getFunctionColumns(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.Ref readRef()> scored 1.0
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.Blob readBlob()> scored 1.0
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.Array readArray()> scored 1.0
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.NClob readNClob()> scored 1.0
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.SQLXML readSQLXML()> scored 1.0
<lsp.test.jdk.util.sql.SQLInput: lsp.test.jdk.util.sql.RowId readRowId()> scored 1.0
<lsp.test.jdk.util.ULocale$IDParser: void <init>(java.lang.String,lsp.test.jdk.util.ULocale$1)> scored 1.0
<lsp.test.jdk.util.ULocale$IDParser: void <init>(java.lang.String,boolean,lsp.test.jdk.util.ULocale$1)> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.DatabaseMetaData getMetaData()> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.CallableStatement prepareCall(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.CallableStatement prepareCall(java.lang.String,int,int)> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.CallableStatement prepareCall(java.lang.String,int,int,int)> scored 1.0
<lsp.test.jdk.util.sql.Connection: void releaseSavepoint(lsp.test.jdk.util.sql.Savepoint)> scored 1.0
<lsp.test.jdk.util.sql.Connection: void rollback(lsp.test.jdk.util.sql.Savepoint)> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Savepoint setSavepoint()> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Savepoint setSavepoint(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.Blob createBlob()> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.NClob createNClob()> scored 1.0
<lsp.test.jdk.util.sql.Connection: lsp.test.jdk.util.sql.SQLXML createSQLXML()> scored 1.0
<lsp.test.jdk.util.Collections$EmptySet$1: void <init>(lsp.test.jdk.util.Collections$EmptySet)> scored 1.0
<lsp.test.jdk.util.UResourceBundle$ResourceCacheKey: void <init>(lsp.test.jdk.util.UResourceBundle$1)> scored 1.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader: void <init>(lsp.test.jdk.util.ResourceBundle$1)> scored 1.0
<lsp.test.jdk.util.sql.Array: lsp.test.jdk.util.sql.ResultSet getResultSet()> scored 1.0
<lsp.test.jdk.util.sql.Array: lsp.test.jdk.util.sql.ResultSet getResultSet(long,int)> scored 1.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap$AscendingEntrySetView: void <init>(lsp.test.jdk.util.TreeMap$AscendingSubMap)> scored 1.0
<lsp.test.jdk.util.XMLUtils$EH: void <init>(lsp.test.jdk.util.XMLUtils$1)> scored 1.0
<lsp.test.jdk.util.sql.DriverManager: void deregisterDriver(lsp.test.jdk.util.sql.Driver)> scored 1.0
<lsp.test.jdk.util.sql.DriverManager: lsp.test.jdk.util.sql.Connection getConnection(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DriverManager: lsp.test.jdk.util.sql.Connection getConnection(java.lang.String,java.lang.String,java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DriverManager: lsp.test.jdk.util.sql.Driver getDriver(java.lang.String)> scored 1.0
<lsp.test.jdk.util.sql.DriverManager: void registerDriver(lsp.test.jdk.util.sql.Driver)> scored 1.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$1: void remove()> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: java.lang.String getCatalogName(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: java.lang.String getColumnClassName(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: int getColumnCount()> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: int getColumnDisplaySize(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: java.lang.String getColumnLabel(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: java.lang.String getColumnName(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: int getColumnType(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: java.lang.String getColumnTypeName(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: int getPrecision(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: int getScale(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: java.lang.String getSchemaName(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: java.lang.String getTableName(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isAutoIncrement(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isCaseSensitive(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isCurrency(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isDefinitelyWritable(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: int isNullable(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isReadOnly(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isSearchable(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isSigned(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSetMetaData: boolean isWritable(int)> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$EntrySetView: int size()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$EntrySetView: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.TreeMap$KeySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$KeySet: java.util.Iterator descendingIterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$KeySet: int size()> scored 0.0
<lsp.test.jdk.util.TreeMap$KeySet: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.TreeMap$KeySet: void clear()> scored 0.0
<lsp.test.jdk.util.AttributedString: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.IllegalFormatPrecisionException: void <init>(int)> scored 0.0
<lsp.test.jdk.util.IllegalFormatPrecisionException: int getPrecision()> scored 0.0
<lsp.test.jdk.util.IllegalFormatPrecisionException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet$EnumSetIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet$EnumSetIterator: java.lang.Enum next()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet$EnumSetIterator: void remove()> scored 0.0
<lsp.test.jdk.util.ULocale: void initLanguageTables()> scored 0.0
<lsp.test.jdk.util.ULocale: void initCountryTables()> scored 0.0
<lsp.test.jdk.util.ULocale: void initCANONICALIZE_MAP()> scored 0.0
<lsp.test.jdk.util.ULocale: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: void <init>(java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String lscvToID(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: int hashCode()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] getISOCountries()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] getISOLanguages()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getLanguage()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getLanguage(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getScript()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getScript(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getCountry()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getCountry(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getVariant()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getVariant(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getFallback(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getFallbackString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getBaseName()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getBaseName(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getName()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getName(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.ULocale: java.util.Iterator getKeywords()> scored 0.0
<lsp.test.jdk.util.ULocale: java.util.Iterator getKeywords(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getKeywordValue(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getKeywordValue(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: int findIndex(java.lang.String[],java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String canonicalize(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String setKeywordValue(java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getISO3Language()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getISO3Language(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getISO3Country()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getISO3Country(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getTableString(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayLanguage()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayLanguage(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getCurrentCountryID(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getCurrentLanguageID(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayLanguageInternal(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayScript()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayScript(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayScriptInternal(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayCountry()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayCountry(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayCountryInternal(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayVariant()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayVariant(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayVariantInternal(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeyword(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeyword(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeywordInternal(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeywordValue(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeywordValue(java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayKeywordValueInternal(java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayName()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayName(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getDisplayNameInternal(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getCharacterOrientation()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String getLineOrientation()> scored 0.0
<lsp.test.jdk.util.ULocale: boolean isEmptyString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: void appendTag(java.lang.String,java.lang.StringBuffer)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String createTagString(java.lang.String,java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String createTagString(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: int parseTagString(java.lang.String,java.lang.String[])> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String lookupLikelySubtags(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String createLikelySubtagsString(java.lang.String,java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: void access$100()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$200()> scored 0.0
<lsp.test.jdk.util.ULocale: int access$300(java.lang.String[],java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$400()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$500()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$600()> scored 0.0
<lsp.test.jdk.util.ULocale: void access$700()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$800()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$900()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$1000()> scored 0.0
<lsp.test.jdk.util.ULocale: java.lang.String[] access$1100()> scored 0.0
<lsp.test.jdk.util.ULocale: void <clinit>()> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTimeoutException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientConnectionException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.EmptyStackException: void <init>()> scored 0.0
<lsp.test.jdk.util.ServiceLoader: void reload()> scored 0.0
<lsp.test.jdk.util.ServiceLoader: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.ServiceLoader: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$Values: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$Values: int size()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$Values: void clear()> scored 0.0
<lsp.test.jdk.util.Collator$1: void <init>()> scored 0.0
<lsp.test.jdk.util.Collator$1: java.lang.Integer run()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$Control$1: java.io.InputStream run()> scored 0.0
<lsp.test.jdk.util.IllegalFormatFlagsException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.IllegalFormatFlagsException: java.lang.String getFlags()> scored 0.0
<lsp.test.jdk.util.IllegalFormatFlagsException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.XMLUtils$Resolver: void <init>()> scored 0.0
<lsp.test.jdk.util.XMLUtils$Resolver: org.xml.sax.InputSource resolveEntity(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.AbstractMap$2$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.AbstractMap$2$1: void remove()> scored 0.0
<lsp.test.jdk.util.sql.Savepoint: int getSavepointId()> scored 0.0
<lsp.test.jdk.util.sql.Savepoint: java.lang.String getSavepointName()> scored 0.0
<lsp.test.jdk.util.InvalidPropertiesFormatException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.InvalidPropertiesFormatException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.InvalidPropertiesFormatException: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.InvalidPropertiesFormatException: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.AbstractMap$1$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.AbstractMap$1$1: void remove()> scored 0.0
<lsp.test.jdk.util.IllegalFormatWidthException: void <init>(int)> scored 0.0
<lsp.test.jdk.util.IllegalFormatWidthException: int getWidth()> scored 0.0
<lsp.test.jdk.util.IllegalFormatWidthException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.HashMap$HashIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.HashMap$HashIterator: void remove()> scored 0.0
<lsp.test.jdk.util.AbstractSequentialList: void <init>()> scored 0.0
<lsp.test.jdk.util.AbstractSequentialList: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: int size()> scored 0.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$AsLIFOQueue: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.BitSet: int wordIndex(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void checkInvariants()> scored 0.0
<lsp.test.jdk.util.BitSet: void recalculateWordsInUse()> scored 0.0
<lsp.test.jdk.util.BitSet: void <init>()> scored 0.0
<lsp.test.jdk.util.BitSet: void <init>(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void initWords(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void ensureCapacity(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void expandTo(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void checkRange(int,int)> scored 0.0
<lsp.test.jdk.util.BitSet: void flip(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void flip(int,int)> scored 0.0
<lsp.test.jdk.util.BitSet: void set(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void set(int,boolean)> scored 0.0
<lsp.test.jdk.util.BitSet: void set(int,int)> scored 0.0
<lsp.test.jdk.util.BitSet: void set(int,int,boolean)> scored 0.0
<lsp.test.jdk.util.BitSet: void clear(int)> scored 0.0
<lsp.test.jdk.util.BitSet: void clear(int,int)> scored 0.0
<lsp.test.jdk.util.BitSet: void clear()> scored 0.0
<lsp.test.jdk.util.BitSet: boolean get(int)> scored 0.0
<lsp.test.jdk.util.BitSet: int nextSetBit(int)> scored 0.0
<lsp.test.jdk.util.BitSet: int nextClearBit(int)> scored 0.0
<lsp.test.jdk.util.BitSet: int length()> scored 0.0
<lsp.test.jdk.util.BitSet: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.BitSet: int cardinality()> scored 0.0
<lsp.test.jdk.util.BitSet: int hashCode()> scored 0.0
<lsp.test.jdk.util.BitSet: int size()> scored 0.0
<lsp.test.jdk.util.BitSet: void trimToSize()> scored 0.0
<lsp.test.jdk.util.BitSet: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.BitSet: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.BitSet: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.BitSet: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Currency$1: void <init>()> scored 0.0
<lsp.test.jdk.util.JDKTest: void <init>()> scored 0.0
<lsp.test.jdk.util.JDKTest: void mainLSPChecker(java.lang.String[])> scored 0.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: int hashCode()> scored 0.0
<lsp.test.jdk.util.AbstractMap$SimpleEntry: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.AttributedCharacterIterator: int getRunLimit()> scored 0.0
<lsp.test.jdk.util.AttributedCharacterIterator: int getRunStart()> scored 0.0
<lsp.test.jdk.util.ULocale$Type: void <init>()> scored 0.0
<lsp.test.jdk.util.Collections$EmptySet: void <init>()> scored 0.0
<lsp.test.jdk.util.Collections$EmptySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$EmptySet: int size()> scored 0.0
<lsp.test.jdk.util.Collator: void <init>()> scored 0.0
<lsp.test.jdk.util.Collator: int compare(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Collator: boolean equals(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Collator: java.util.Locale[] getAvailableLocales()> scored 0.0
<lsp.test.jdk.util.Collator: int getDecomposition()> scored 0.0
<lsp.test.jdk.util.Collator: int getStrength()> scored 0.0
<lsp.test.jdk.util.Collator: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collator: void setDecomposition(int)> scored 0.0
<lsp.test.jdk.util.Collator: void setStrength(int)> scored 0.0
<lsp.test.jdk.util.Collator: int decompositionMode_Java_ICU(int)> scored 0.0
<lsp.test.jdk.util.Collator: int decompositionMode_ICU_Java(int)> scored 0.0
<lsp.test.jdk.util.Collator: int strength_Java_ICU(int)> scored 0.0
<lsp.test.jdk.util.Collator: int strength_ICU_Java(int)> scored 0.0
<lsp.test.jdk.util.Collator: void <clinit>()> scored 0.0
<lsp.test.jdk.util.LinkedHashSet: void <init>(int,float)> scored 0.0
<lsp.test.jdk.util.LinkedHashSet: void <init>(int)> scored 0.0
<lsp.test.jdk.util.LinkedHashSet: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void addBatch()> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void clearParameters()> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: boolean execute()> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: int executeUpdate()> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setAsciiStream(int,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBigDecimal(int,java.math.BigDecimal)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBinaryStream(int,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBoolean(int,boolean)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setByte(int,byte)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBytes(int,byte[])> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setCharacterStream(int,java.io.Reader,int)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setDouble(int,double)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setFloat(int,float)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setInt(int,int)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setLong(int,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNull(int,int)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNull(int,int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setShort(int,short)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setString(int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setUnicodeStream(int,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setURL(int,java.net.URL)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNString(int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNCharacterStream(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setClob(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBlob(int,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNClob(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setAsciiStream(int,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBinaryStream(int,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setCharacterStream(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setAsciiStream(int,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBinaryStream(int,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setCharacterStream(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNCharacterStream(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setClob(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setBlob(int,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.PreparedStatement: void setNClob(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: java.util.Iterator keyIterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap: java.util.Iterator descendingKeyIterator()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: void <init>()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.lang.String getLocaleID()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.lang.String getBaseName()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: void resetBundleCache()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: int getRootType(java.lang.String,java.lang.ClassLoader)> scored 0.0
<lsp.test.jdk.util.UResourceBundle: void setRootType(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.nio.ByteBuffer getBinary()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.lang.String getString()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.lang.String[] getStringArray()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: byte[] getBinary(byte[])> scored 0.0
<lsp.test.jdk.util.UResourceBundle: int[] getIntVector()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: int getInt()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: int getUInt()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.lang.String getString(int)> scored 0.0
<lsp.test.jdk.util.UResourceBundle: void initKeysVector()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: int getSize()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: int getType()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.lang.String getKey()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: java.lang.String[] handleGetStringArray()> scored 0.0
<lsp.test.jdk.util.UResourceBundle: void setLoadingStatus(int)> scored 0.0
<lsp.test.jdk.util.UResourceBundle: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection$1: void remove()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$NoFallbackControl: void <clinit>()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean absolute(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void afterLast()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void beforeFirst()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void cancelRowUpdates()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void clearWarnings()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void close()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void deleteRow()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int findColumn(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean first()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.InputStream getAsciiStream(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.InputStream getAsciiStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.math.BigDecimal getBigDecimal(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.math.BigDecimal getBigDecimal(int,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.math.BigDecimal getBigDecimal(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.math.BigDecimal getBigDecimal(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.InputStream getBinaryStream(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.InputStream getBinaryStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean getBoolean(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean getBoolean(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: byte getByte(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: byte getByte(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: byte[] getBytes(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: byte[] getBytes(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.Reader getCharacterStream(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.Reader getCharacterStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getConcurrency()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.String getCursorName()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: double getDouble(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: double getDouble(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getFetchDirection()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getFetchSize()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: float getFloat(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: float getFloat(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getInt(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getInt(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: long getLong(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: long getLong(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getRow()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: short getShort(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: short getShort(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.String getString(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.String getString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getType()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.InputStream getUnicodeStream(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.InputStream getUnicodeStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.net.URL getURL(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.net.URL getURL(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void insertRow()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean isAfterLast()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean isBeforeFirst()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean isFirst()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean isLast()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean last()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void moveToCurrentRow()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void moveToInsertRow()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean next()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean previous()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void refreshRow()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean relative(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean rowDeleted()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean rowInserted()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean rowUpdated()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void setFetchDirection(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void setFetchSize(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateAsciiStream(int,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateAsciiStream(java.lang.String,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBigDecimal(int,java.math.BigDecimal)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBigDecimal(java.lang.String,java.math.BigDecimal)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBinaryStream(int,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBinaryStream(java.lang.String,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBoolean(int,boolean)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBoolean(java.lang.String,boolean)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateByte(int,byte)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateByte(java.lang.String,byte)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBytes(int,byte[])> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBytes(java.lang.String,byte[])> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateCharacterStream(int,java.io.Reader,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateCharacterStream(java.lang.String,java.io.Reader,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateDouble(int,double)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateDouble(java.lang.String,double)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateFloat(int,float)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateFloat(java.lang.String,float)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateInt(int,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateInt(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateLong(int,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateLong(java.lang.String,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNull(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNull(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateRow()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateShort(int,short)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateShort(java.lang.String,short)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateString(int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateString(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean wasNull()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: int getHoldability()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: boolean isClosed()> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNString(int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNString(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.String getNString(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.lang.String getNString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.Reader getNCharacterStream(int)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: java.io.Reader getNCharacterStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNCharacterStream(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNCharacterStream(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateAsciiStream(int,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBinaryStream(int,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateCharacterStream(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateAsciiStream(java.lang.String,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBinaryStream(java.lang.String,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateCharacterStream(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBlob(int,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBlob(java.lang.String,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateClob(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateClob(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNClob(int,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNClob(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNCharacterStream(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNCharacterStream(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateAsciiStream(int,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBinaryStream(int,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateCharacterStream(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateAsciiStream(java.lang.String,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBinaryStream(java.lang.String,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateCharacterStream(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBlob(int,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateBlob(java.lang.String,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateClob(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateClob(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNClob(int,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.ResultSet: void updateNClob(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.ServiceLoader$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.ServiceLoader$1: void remove()> scored 0.0
<lsp.test.jdk.util.Hashtable$EmptyIterator: void <init>()> scored 0.0
<lsp.test.jdk.util.Hashtable$EmptyIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Hashtable$EmptyIterator: void remove()> scored 0.0
<lsp.test.jdk.util.sql.RowIdLifetime: void <init>(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.RowIdLifetime: void <clinit>()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$DescendingSubMapKeyIterator: void remove()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedList$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedList$1: boolean hasPrevious()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedList$1: int nextIndex()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedList$1: int previousIndex()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedList$1: void remove()> scored 0.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: java.util.Iterator keyIterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap: java.util.Iterator descendingKeyIterator()> scored 0.0
<lsp.test.jdk.util.Hashtable$Entry: int hashCode()> scored 0.0
<lsp.test.jdk.util.Hashtable$Entry: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: int size()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableCollection: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$SingletonSet$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$SingletonSet$1: void remove()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$Control: void <init>()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$Control: java.lang.String toResourceName(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ResourceBundle$Control: void <clinit>()> scored 0.0
<lsp.test.jdk.util.ParseException: void <init>(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.ParseException: int getErrorOffset()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$DescendingSubMapEntryIterator: void remove()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: void <init>(int,float)> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: void <init>(int)> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: void <init>()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: void <init>(int,float,boolean)> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: void init()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: void clear()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: java.util.Iterator newKeyIterator()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: java.util.Iterator newValueIterator()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap: java.util.Iterator newEntryIterator()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$KeySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$KeySet: int size()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$KeySet: void clear()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$KeySet: int hashCode()> scored 0.0
<lsp.test.jdk.util.EnumMap: int size()> scored 0.0
<lsp.test.jdk.util.EnumMap: void clear()> scored 0.0
<lsp.test.jdk.util.EnumMap: void typeCheck(java.lang.Enum)> scored 0.0
<lsp.test.jdk.util.EnumMap: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.EnumMap: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.EnumMap: void <clinit>()> scored 0.0
<lsp.test.jdk.util.IllegalFormatConversionException: char getConversion()> scored 0.0
<lsp.test.jdk.util.IllegalFormatConversionException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void <init>()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void <init>(int)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: int capacity(int)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void init(int)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: int size()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: int nextKeyIndex(int,int)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void resize(int)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void closeDeletion(int)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void clear()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: int hashCode()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: int access$300(int,int)> scored 0.0
<lsp.test.jdk.util.IdentityHashMap: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Locale: void <init>()> scored 0.0
<lsp.test.jdk.util.Locale: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.Locale: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Locale: void <init>(java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getCountry()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getDisplayCountry()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getDisplayLanguage()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getDisplayName()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getDisplayVariant()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getISO3Country()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getISO3Language()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String[] getISOCountries()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String[] getISOLanguages()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getLanguage()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String getVariant()> scored 0.0
<lsp.test.jdk.util.Locale: int hashCode()> scored 0.0
<lsp.test.jdk.util.Locale: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Locale: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.Locale: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.Locale: void <clinit>()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: java.lang.String getName()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: java.lang.ClassLoader getLoader()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: int hashCode()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: void calculateHashCode()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: java.lang.String getFormat()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: void setFormat(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: void setCause(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: java.lang.Throwable getCause()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$CacheKey: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.LinkedList: void <init>()> scored 0.0
<lsp.test.jdk.util.LinkedList: int size()> scored 0.0
<lsp.test.jdk.util.LinkedList: void clear()> scored 0.0
<lsp.test.jdk.util.LinkedList: java.util.Iterator descendingIterator()> scored 0.0
<lsp.test.jdk.util.LinkedList: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.LinkedList: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void <init>()> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void validateFormat(char)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void validatePattern(java.lang.String)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void applyLocalizedPattern(java.lang.String)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void applyPattern(java.lang.String)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: java.lang.String patternForICU(java.lang.String)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void appendTimeZone(java.lang.StringBuffer,int,boolean)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void appendNumber(java.lang.StringBuffer,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: int hashCode()> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: java.lang.String toLocalizedPattern()> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: java.lang.String toPattern()> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.SimpleDateFormat: void <clinit>()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapIterator: void removeAscending()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapIterator: void removeDescending()> scored 0.0
<lsp.test.jdk.util.AttributedCharacterIterator$Attribute: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AttributedCharacterIterator$Attribute: java.lang.String getName()> scored 0.0
<lsp.test.jdk.util.AttributedCharacterIterator$Attribute: int hashCode()> scored 0.0
<lsp.test.jdk.util.AttributedCharacterIterator$Attribute: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.AttributedCharacterIterator$Attribute: void <clinit>()> scored 0.0
<lsp.test.jdk.util.MissingFormatWidthException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.MissingFormatWidthException: java.lang.String getFormatSpecifier()> scored 0.0
<lsp.test.jdk.util.MissingFormatWidthException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.EventObject: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.HashMap$KeySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.HashMap$KeySet: int size()> scored 0.0
<lsp.test.jdk.util.HashMap$KeySet: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableSet: int hashCode()> scored 0.0
<lsp.test.jdk.util.PriorityQueue$Itr: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.PriorityQueue$Itr: void remove()> scored 0.0
<lsp.test.jdk.util.Collections$SingletonSet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$SingletonSet: int size()> scored 0.0
<lsp.test.jdk.util.sql.Blob: java.io.InputStream getBinaryStream()> scored 0.0
<lsp.test.jdk.util.sql.Blob: byte[] getBytes(long,int)> scored 0.0
<lsp.test.jdk.util.sql.Blob: long length()> scored 0.0
<lsp.test.jdk.util.sql.Blob: long position(byte[],long)> scored 0.0
<lsp.test.jdk.util.sql.Blob: java.io.OutputStream setBinaryStream(long)> scored 0.0
<lsp.test.jdk.util.sql.Blob: int setBytes(long,byte[])> scored 0.0
<lsp.test.jdk.util.sql.Blob: int setBytes(long,byte[],int,int)> scored 0.0
<lsp.test.jdk.util.sql.Blob: void truncate(long)> scored 0.0
<lsp.test.jdk.util.sql.Blob: void free()> scored 0.0
<lsp.test.jdk.util.sql.Blob: java.io.InputStream getBinaryStream(long,long)> scored 0.0
<lsp.test.jdk.util.DateFormat: void <init>()> scored 0.0
<lsp.test.jdk.util.DateFormat: java.lang.String getStyleName(int)> scored 0.0
<lsp.test.jdk.util.DateFormat: int hashCode()> scored 0.0
<lsp.test.jdk.util.DateFormat: boolean isLenient()> scored 0.0
<lsp.test.jdk.util.DateFormat: void setLenient(boolean)> scored 0.0
<lsp.test.jdk.util.DuplicateFormatFlagsException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.DuplicateFormatFlagsException: java.lang.String getFlags()> scored 0.0
<lsp.test.jdk.util.DuplicateFormatFlagsException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLFeatureNotSupportedException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.IllegalFormatCodePointException: void <init>(int)> scored 0.0
<lsp.test.jdk.util.IllegalFormatCodePointException: int getCodePoint()> scored 0.0
<lsp.test.jdk.util.IllegalFormatCodePointException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.AbstractQueue: void <init>()> scored 0.0
<lsp.test.jdk.util.AbstractQueue: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: int size()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedCollection: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.ParsePosition: void <init>(int)> scored 0.0
<lsp.test.jdk.util.ParsePosition: int getErrorIndex()> scored 0.0
<lsp.test.jdk.util.ParsePosition: int getIndex()> scored 0.0
<lsp.test.jdk.util.ParsePosition: int hashCode()> scored 0.0
<lsp.test.jdk.util.ParsePosition: void setErrorIndex(int)> scored 0.0
<lsp.test.jdk.util.ParsePosition: void setIndex(int)> scored 0.0
<lsp.test.jdk.util.ParsePosition: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.EnumSet: void addAll()> scored 0.0
<lsp.test.jdk.util.EnumSet: void addRange(java.lang.Enum,java.lang.Enum)> scored 0.0
<lsp.test.jdk.util.EnumSet: void complement()> scored 0.0
<lsp.test.jdk.util.EnumSet: void typeCheck(java.lang.Enum)> scored 0.0
<lsp.test.jdk.util.EnumSet: java.lang.Enum[] access$000()> scored 0.0
<lsp.test.jdk.util.EnumSet: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Collections$EmptyMap: void <init>()> scored 0.0
<lsp.test.jdk.util.Collections$EmptyMap: int size()> scored 0.0
<lsp.test.jdk.util.Collections$EmptyMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$EmptyMap: int hashCode()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: char current()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: char first()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: int getBeginIndex()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: int getEndIndex()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: int getIndex()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: char last()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: char next()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: char previous()> scored 0.0
<lsp.test.jdk.util.CharacterIterator: char setIndex(int)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransientException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedSet: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections: void <init>()> scored 0.0
<lsp.test.jdk.util.Collections: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Hashtable$Enumerator: boolean hasMoreElements()> scored 0.0
<lsp.test.jdk.util.Hashtable$Enumerator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Hashtable$Enumerator: void remove()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: boolean hasPrevious()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: int nextIndex()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: int previousIndex()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableList$1: void remove()> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLException: int getErrorCode()> scored 0.0
<lsp.test.jdk.util.sql.SQLException: java.lang.String getSQLState()> scored 0.0
<lsp.test.jdk.util.sql.SQLException: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.UnknownFormatFlagsException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.UnknownFormatFlagsException: java.lang.String getFlags()> scored 0.0
<lsp.test.jdk.util.UnknownFormatFlagsException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.sql.SQLData: java.lang.String getSQLTypeName()> scored 0.0
<lsp.test.jdk.util.TimeZone: void initializeAvailable()> scored 0.0
<lsp.test.jdk.util.TimeZone: boolean isAvailableIDInICU(java.lang.String)> scored 0.0
<lsp.test.jdk.util.TimeZone: void appendAvailableZones(java.lang.String)> scored 0.0
<lsp.test.jdk.util.TimeZone: void <init>()> scored 0.0
<lsp.test.jdk.util.TimeZone: java.lang.String[] getAvailableIDs()> scored 0.0
<lsp.test.jdk.util.TimeZone: java.lang.String[] getAvailableIDs(int)> scored 0.0
<lsp.test.jdk.util.TimeZone: java.lang.String getDisplayName()> scored 0.0
<lsp.test.jdk.util.TimeZone: java.lang.String getDisplayName(boolean,int)> scored 0.0
<lsp.test.jdk.util.TimeZone: java.lang.String getID()> scored 0.0
<lsp.test.jdk.util.TimeZone: int getDSTSavings()> scored 0.0
<lsp.test.jdk.util.TimeZone: int getOffset(long)> scored 0.0
<lsp.test.jdk.util.TimeZone: int getOffset(int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.TimeZone: int getRawOffset()> scored 0.0
<lsp.test.jdk.util.TimeZone: java.lang.String formatTimeZoneName(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.TimeZone: int parseNumber(java.lang.String,int,int[])> scored 0.0
<lsp.test.jdk.util.TimeZone: void setID(java.lang.String)> scored 0.0
<lsp.test.jdk.util.TimeZone: void setRawOffset(int)> scored 0.0
<lsp.test.jdk.util.TimeZone: boolean useDaylightTime()> scored 0.0
<lsp.test.jdk.util.TimeZone: java.lang.String getCustomTimeZone(int[],boolean[])> scored 0.0
<lsp.test.jdk.util.TimeZone: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Format: void <init>()> scored 0.0
<lsp.test.jdk.util.Format: java.lang.String convertPattern(java.lang.String,java.lang.String,java.lang.String,boolean)> scored 0.0
<lsp.test.jdk.util.TreeMap$EntrySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$EntrySet: int size()> scored 0.0
<lsp.test.jdk.util.TreeMap$EntrySet: void clear()> scored 0.0
<lsp.test.jdk.util.TreeMap$DescendingSubMap$DescendingEntrySetView: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedCollection: int size()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedCollection: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedCollection: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedCollection: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedCollection: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.sql.Statement: void addBatch(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Statement: void cancel()> scored 0.0
<lsp.test.jdk.util.sql.Statement: void clearBatch()> scored 0.0
<lsp.test.jdk.util.sql.Statement: void clearWarnings()> scored 0.0
<lsp.test.jdk.util.sql.Statement: void close()> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean execute(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean execute(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean execute(java.lang.String,int[])> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean execute(java.lang.String,java.lang.String[])> scored 0.0
<lsp.test.jdk.util.sql.Statement: int[] executeBatch()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int executeUpdate(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Statement: int executeUpdate(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: int executeUpdate(java.lang.String,int[])> scored 0.0
<lsp.test.jdk.util.sql.Statement: int executeUpdate(java.lang.String,java.lang.String[])> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getFetchDirection()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getFetchSize()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getMaxFieldSize()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getMaxRows()> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean getMoreResults()> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean getMoreResults(int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getQueryTimeout()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getResultSetConcurrency()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getResultSetHoldability()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getResultSetType()> scored 0.0
<lsp.test.jdk.util.sql.Statement: int getUpdateCount()> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setCursorName(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setEscapeProcessing(boolean)> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setFetchDirection(int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setFetchSize(int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setMaxFieldSize(int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setMaxRows(int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setQueryTimeout(int)> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean isClosed()> scored 0.0
<lsp.test.jdk.util.sql.Statement: void setPoolable(boolean)> scored 0.0
<lsp.test.jdk.util.sql.Statement: boolean isPoolable()> scored 0.0
<lsp.test.jdk.util.Arrays: void <init>()> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(long[])> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(long[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(int[])> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(int[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(short[])> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(short[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(char[])> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(char[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(byte[])> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(byte[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(double[])> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(double[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(float[])> scored 0.0
<lsp.test.jdk.util.Arrays: void sort(float[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort2(double[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort2(float[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort1(long[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void swap(long[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void vecswap(long[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int med3(long[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort1(int[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void swap(int[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void vecswap(int[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int med3(int[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort1(short[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void swap(short[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void vecswap(short[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int med3(short[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort1(char[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void swap(char[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void vecswap(char[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int med3(char[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort1(byte[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void swap(byte[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void vecswap(byte[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int med3(byte[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort1(double[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void swap(double[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void vecswap(double[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int med3(double[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void sort1(float[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void swap(float[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void vecswap(float[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int med3(float[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void rangeCheck(int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(long[],long)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(long[],int,int,long)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch0(long[],int,int,long)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(int[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(int[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch0(int[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(short[],short)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(short[],int,int,short)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch0(short[],int,int,short)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(char[],char)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(char[],int,int,char)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch0(char[],int,int,char)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(byte[],byte)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(byte[],int,int,byte)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch0(byte[],int,int,byte)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(double[],double)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(double[],int,int,double)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch0(double[],int,int,double)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(float[],float)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch(float[],int,int,float)> scored 0.0
<lsp.test.jdk.util.Arrays: int binarySearch0(float[],int,int,float)> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(long[],long[])> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(int[],int[])> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(short[],short[])> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(char[],char[])> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(byte[],byte[])> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(boolean[],boolean[])> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(double[],double[])> scored 0.0
<lsp.test.jdk.util.Arrays: boolean equals(float[],float[])> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(long[],long)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(long[],int,int,long)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(int[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(int[],int,int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(short[],short)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(short[],int,int,short)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(char[],char)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(char[],int,int,char)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(byte[],byte)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(byte[],int,int,byte)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(boolean[],boolean)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(boolean[],int,int,boolean)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(double[],double)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(double[],int,int,double)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(float[],float)> scored 0.0
<lsp.test.jdk.util.Arrays: void fill(float[],int,int,float)> scored 0.0
<lsp.test.jdk.util.Arrays: byte[] copyOf(byte[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: short[] copyOf(short[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: int[] copyOf(int[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: long[] copyOf(long[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: char[] copyOf(char[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: float[] copyOf(float[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: double[] copyOf(double[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: boolean[] copyOf(boolean[],int)> scored 0.0
<lsp.test.jdk.util.Arrays: byte[] copyOfRange(byte[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: short[] copyOfRange(short[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int[] copyOfRange(int[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: long[] copyOfRange(long[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: char[] copyOfRange(char[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: float[] copyOfRange(float[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: double[] copyOfRange(double[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: boolean[] copyOfRange(boolean[],int,int)> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(long[])> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(int[])> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(short[])> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(char[])> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(byte[])> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(boolean[])> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(float[])> scored 0.0
<lsp.test.jdk.util.Arrays: int hashCode(double[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(long[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(int[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(short[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(char[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(byte[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(boolean[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(float[])> scored 0.0
<lsp.test.jdk.util.Arrays: java.lang.String toString(double[])> scored 0.0
<lsp.test.jdk.util.Enumeration: boolean hasMoreElements()> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLInvalidAuthorizationSpecException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.Driver: boolean acceptsURL(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Driver: int getMajorVersion()> scored 0.0
<lsp.test.jdk.util.sql.Driver: int getMinorVersion()> scored 0.0
<lsp.test.jdk.util.sql.Driver: boolean jdbcCompliant()> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(int[],java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(java.lang.String,int[],java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(java.lang.String,java.lang.String,int[],java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(java.lang.String,java.lang.String,int,int[],java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(int[])> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(java.lang.String,int[])> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(java.lang.String,java.lang.String,int[])> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: void <init>(java.lang.String,java.lang.String,int,int[])> scored 0.0
<lsp.test.jdk.util.sql.BatchUpdateException: int[] getUpdateCounts()> scored 0.0
<lsp.test.jdk.util.AbstractCollection: void <init>()> scored 0.0
<lsp.test.jdk.util.AbstractCollection: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.AbstractCollection: int size()> scored 0.0
<lsp.test.jdk.util.AbstractCollection: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.AbstractCollection: void clear()> scored 0.0
<lsp.test.jdk.util.AbstractCollection: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.AbstractList: void <init>()> scored 0.0
<lsp.test.jdk.util.AbstractList: void clear()> scored 0.0
<lsp.test.jdk.util.AbstractList: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.AbstractList: int hashCode()> scored 0.0
<lsp.test.jdk.util.AbstractList: void removeRange(int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void <init>()> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void <init>(int,int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void <init>(int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void <init>(int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void <init>(long)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void <init>(boolean)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void add(int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void fullFieldsCalc(long,int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void cachedFieldsCheckAndGet(long,long,long,int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void computeFields()> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void computeTime()> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int computeYearAndDay(long,long)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: long daysFromBaseYear(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int daysInMonth()> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int daysInMonth(boolean,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int daysInYear(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int daysInYear(boolean,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int getActualMaximum(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int getActualMinimum(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int getGreatestMinimum(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int getLeastMaximum(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int getMaximum(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int getMinimum(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int getOffset(long)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int hashCode()> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: boolean isLeapYear(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int julianError()> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int mod(int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: int mod7(long)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void roll(int,int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void roll(int,boolean)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void setFirstDayOfWeek(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void setMinimalDaysInFirstWeek(int)> scored 0.0
<lsp.test.jdk.util.GregorianCalendar: void <clinit>()> scored 0.0
<lsp.test.jdk.util.ServiceConfigurationError: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ServiceConfigurationError: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.ListResourceBundle: void <init>()> scored 0.0
<lsp.test.jdk.util.ListResourceBundle: void loadLookup()> scored 0.0
<lsp.test.jdk.util.Collections$1: boolean hasMoreElements()> scored 0.0
<lsp.test.jdk.util.LinkedList$ListItr: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.LinkedList$ListItr: boolean hasPrevious()> scored 0.0
<lsp.test.jdk.util.LinkedList$ListItr: int nextIndex()> scored 0.0
<lsp.test.jdk.util.LinkedList$ListItr: int previousIndex()> scored 0.0
<lsp.test.jdk.util.LinkedList$ListItr: void remove()> scored 0.0
<lsp.test.jdk.util.LinkedList$ListItr: void checkForComodification()> scored 0.0
<lsp.test.jdk.util.sql.DataTruncation: void <init>(int,boolean,boolean,int,int)> scored 0.0
<lsp.test.jdk.util.sql.DataTruncation: void <init>(int,boolean,boolean,int,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.DataTruncation: int getDataSize()> scored 0.0
<lsp.test.jdk.util.sql.DataTruncation: int getIndex()> scored 0.0
<lsp.test.jdk.util.sql.DataTruncation: boolean getParameter()> scored 0.0
<lsp.test.jdk.util.sql.DataTruncation: boolean getRead()> scored 0.0
<lsp.test.jdk.util.sql.DataTruncation: int getTransferSize()> scored 0.0
<lsp.test.jdk.util.ULocale$1ULocaleAcceptLanguageQ: void <init>(double,int)> scored 0.0
<lsp.test.jdk.util.Deque: int size()> scored 0.0
<lsp.test.jdk.util.Deque: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Deque: java.util.Iterator descendingIterator()> scored 0.0
<lsp.test.jdk.util.AbstractMap: void <init>()> scored 0.0
<lsp.test.jdk.util.AbstractMap: int size()> scored 0.0
<lsp.test.jdk.util.AbstractMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.AbstractMap: void clear()> scored 0.0
<lsp.test.jdk.util.AbstractMap: int hashCode()> scored 0.0
<lsp.test.jdk.util.AbstractMap: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.ServiceLoader$LazyIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.ServiceLoader$LazyIterator: void remove()> scored 0.0
<lsp.test.jdk.util.MissingFormatArgumentException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.MissingFormatArgumentException: java.lang.String getFormatSpecifier()> scored 0.0
<lsp.test.jdk.util.MissingFormatArgumentException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$EntrySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$EntrySet: int size()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$EntrySet: void clear()> scored 0.0
<lsp.test.jdk.util.AbstractMap$1: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.AbstractMap$1: int size()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet$CheckedEntry: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.TreeMap$Values: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$Values: int size()> scored 0.0
<lsp.test.jdk.util.TreeMap$Values: void clear()> scored 0.0
<lsp.test.jdk.util.Hashtable: void <init>(int,float)> scored 0.0
<lsp.test.jdk.util.Hashtable: void <init>(int)> scored 0.0
<lsp.test.jdk.util.Hashtable: void <init>()> scored 0.0
<lsp.test.jdk.util.Hashtable: int size()> scored 0.0
<lsp.test.jdk.util.Hashtable: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Hashtable: void rehash()> scored 0.0
<lsp.test.jdk.util.Hashtable: void clear()> scored 0.0
<lsp.test.jdk.util.Hashtable: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Hashtable: java.util.Iterator getIterator(int)> scored 0.0
<lsp.test.jdk.util.Hashtable: int hashCode()> scored 0.0
<lsp.test.jdk.util.Hashtable: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.Hashtable: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.Hashtable: void <clinit>()> scored 0.0
<lsp.test.jdk.util.SubList: int size()> scored 0.0
<lsp.test.jdk.util.SubList: void removeRange(int,int)> scored 0.0
<lsp.test.jdk.util.SubList: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.SubList: void rangeCheck(int)> scored 0.0
<lsp.test.jdk.util.SubList: void checkForComodification()> scored 0.0
<lsp.test.jdk.util.sql.SQLPermission: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLPermission: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: void setLoadingStatus(int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int getLoadingStatus()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: void setLoadingStatus(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.String getResPath()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.String[] getKeywordValues(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.String getStringWithFallback(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.String[] createLocaleNameArray(java.lang.String,java.lang.ClassLoader)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.String getLocaleID()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.String getBaseName()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: boolean getNoFallback()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: void <init>()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int RES_GET_TYPE(long)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int RES_GET_OFFSET(long)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int RES_GET_INT(long)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: long RES_GET_UINT(long)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.StringBuffer RES_GET_KEY(byte[],int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int getIntOffset(int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int getCharOffset(int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int getOffset(int,int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: char makeChar(byte[],int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: char getChar(byte[],int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int makeInt(byte[],int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int getInt(byte[],int)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: java.lang.String getStringValue(long)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: int getIndex(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: void createLookupCache()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Hashtable$EmptyEnumerator: void <init>()> scored 0.0
<lsp.test.jdk.util.Hashtable$EmptyEnumerator: boolean hasMoreElements()> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLIntegrityConstraintViolationException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$1: void remove()> scored 0.0
<lsp.test.jdk.util.Collections$SetFromMap: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$SetFromMap: int size()> scored 0.0
<lsp.test.jdk.util.Collections$SetFromMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$SetFromMap: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collections$SetFromMap: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$SetFromMap: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$SetFromMap: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.Collections$ReverseComparator: void <init>()> scored 0.0
<lsp.test.jdk.util.Collections$ReverseComparator: int compare(java.lang.Comparable,java.lang.Comparable)> scored 0.0
<lsp.test.jdk.util.sql.DriverPropertyInfo: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Collections$CheckedList: int hashCode()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: int hashCode()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$EntryIterator: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: void addRange(java.lang.Enum,java.lang.Enum)> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: void addAll()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: void complement()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: int size()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: boolean add(java.lang.Enum)> scored 0.0
<lsp.test.jdk.util.RegularEnumSet: void clear()> scored 0.0
<lsp.test.jdk.util.ArrayDeque$DescendingIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.ArrayDeque$DescendingIterator: void remove()> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLRecoverableException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.TreeMap$Entry: int hashCode()> scored 0.0
<lsp.test.jdk.util.TreeMap$Entry: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Annotation: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.sql.Date: void <init>(int,int,int)> scored 0.0
<lsp.test.jdk.util.sql.Date: void <init>(long)> scored 0.0
<lsp.test.jdk.util.sql.Date: int getHours()> scored 0.0
<lsp.test.jdk.util.sql.Date: int getMinutes()> scored 0.0
<lsp.test.jdk.util.sql.Date: int getSeconds()> scored 0.0
<lsp.test.jdk.util.sql.Date: void setHours(int)> scored 0.0
<lsp.test.jdk.util.sql.Date: void setMinutes(int)> scored 0.0
<lsp.test.jdk.util.sql.Date: void setSeconds(int)> scored 0.0
<lsp.test.jdk.util.sql.Date: void setTime(long)> scored 0.0
<lsp.test.jdk.util.sql.Date: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.sql.Date: void format(int,int,java.lang.StringBuilder)> scored 0.0
<lsp.test.jdk.util.sql.Date: long normalizeTime(long)> scored 0.0
<lsp.test.jdk.util.TreeSet: void <init>()> scored 0.0
<lsp.test.jdk.util.TreeSet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.TreeSet: java.util.Iterator descendingIterator()> scored 0.0
<lsp.test.jdk.util.TreeSet: int size()> scored 0.0
<lsp.test.jdk.util.TreeSet: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.TreeSet: void clear()> scored 0.0
<lsp.test.jdk.util.TreeSet: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.TreeSet: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.TreeSet: void <clinit>()> scored 0.0
<lsp.test.jdk.util.ArrayDeque$DeqIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.ArrayDeque$DeqIterator: void remove()> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.math.BigDecimal getBigDecimal(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.math.BigDecimal getBigDecimal(int,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.math.BigDecimal getBigDecimal(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: boolean getBoolean(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: boolean getBoolean(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: byte getByte(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: byte getByte(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: byte[] getBytes(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: byte[] getBytes(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: double getDouble(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: double getDouble(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: float getFloat(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: float getFloat(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: int getInt(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: int getInt(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: long getLong(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: long getLong(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: short getShort(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: short getShort(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.String getString(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.String getString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.net.URL getURL(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.net.URL getURL(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void registerOutParameter(int,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void registerOutParameter(int,int,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void registerOutParameter(int,int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void registerOutParameter(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void registerOutParameter(java.lang.String,int,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void registerOutParameter(java.lang.String,int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setAsciiStream(java.lang.String,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBigDecimal(java.lang.String,java.math.BigDecimal)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBinaryStream(java.lang.String,java.io.InputStream,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBoolean(java.lang.String,boolean)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setByte(java.lang.String,byte)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBytes(java.lang.String,byte[])> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setCharacterStream(java.lang.String,java.io.Reader,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setDouble(java.lang.String,double)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setFloat(java.lang.String,float)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setInt(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setLong(java.lang.String,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setNull(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setNull(java.lang.String,int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setShort(java.lang.String,short)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setString(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setURL(java.lang.String,java.net.URL)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: boolean wasNull()> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setNString(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setNCharacterStream(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setClob(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBlob(java.lang.String,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setNClob(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.String getNString(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.lang.String getNString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.io.Reader getNCharacterStream(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.io.Reader getNCharacterStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.io.Reader getCharacterStream(int)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: java.io.Reader getCharacterStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setAsciiStream(java.lang.String,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBinaryStream(java.lang.String,java.io.InputStream,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setCharacterStream(java.lang.String,java.io.Reader,long)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setAsciiStream(java.lang.String,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBinaryStream(java.lang.String,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setCharacterStream(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setNCharacterStream(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setClob(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setBlob(java.lang.String,java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.CallableStatement: void setNClob(java.lang.String,java.io.Reader)> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void allocateElements(int)> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void doubleCapacity()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void <init>()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void <init>(int)> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void checkInvariants()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: boolean delete(int)> scored 0.0
<lsp.test.jdk.util.ArrayDeque: int size()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: java.util.Iterator descendingIterator()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void clear()> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.ArrayDeque: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet$UnmodifiableEntry: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableList: int hashCode()> scored 0.0
<lsp.test.jdk.util.sql.SQLXML: void free()> scored 0.0
<lsp.test.jdk.util.sql.SQLXML: java.io.InputStream getBinaryStream()> scored 0.0
<lsp.test.jdk.util.sql.SQLXML: java.io.OutputStream setBinaryStream()> scored 0.0
<lsp.test.jdk.util.sql.SQLXML: java.io.Reader getCharacterStream()> scored 0.0
<lsp.test.jdk.util.sql.SQLXML: java.io.Writer setCharacterStream()> scored 0.0
<lsp.test.jdk.util.sql.SQLXML: java.lang.String getString()> scored 0.0
<lsp.test.jdk.util.sql.SQLXML: void setString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapKeyIterator: void remove()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap$SubMapEntryIterator: void remove()> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLDataException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle$AvailEntry: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap: int size()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Observable: void <init>()> scored 0.0
<lsp.test.jdk.util.Observable: void notifyObservers()> scored 0.0
<lsp.test.jdk.util.Observable: void deleteObservers()> scored 0.0
<lsp.test.jdk.util.Observable: void setChanged()> scored 0.0
<lsp.test.jdk.util.Observable: void clearChanged()> scored 0.0
<lsp.test.jdk.util.Observable: boolean hasChanged()> scored 0.0
<lsp.test.jdk.util.Observable: int countObservers()> scored 0.0
<lsp.test.jdk.util.CollationKey: java.lang.String getSourceString()> scored 0.0
<lsp.test.jdk.util.CollationKey: int hashCode()> scored 0.0
<lsp.test.jdk.util.CollationKey: byte[] toByteArray()> scored 0.0
<lsp.test.jdk.util.sql.ClientInfoStatus: void <init>(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.ClientInfoStatus: void <clinit>()> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLWarning: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.Calendar: void <init>()> scored 0.0
<lsp.test.jdk.util.Calendar: void add(int,int)> scored 0.0
<lsp.test.jdk.util.Calendar: void clear()> scored 0.0
<lsp.test.jdk.util.Calendar: void clear(int)> scored 0.0
<lsp.test.jdk.util.Calendar: void complete()> scored 0.0
<lsp.test.jdk.util.Calendar: void computeFields()> scored 0.0
<lsp.test.jdk.util.Calendar: void computeTime()> scored 0.0
<lsp.test.jdk.util.Calendar: int get(int)> scored 0.0
<lsp.test.jdk.util.Calendar: int getActualMaximum(int)> scored 0.0
<lsp.test.jdk.util.Calendar: int getActualMinimum(int)> scored 0.0
<lsp.test.jdk.util.Calendar: int getFirstDayOfWeek()> scored 0.0
<lsp.test.jdk.util.Calendar: int getGreatestMinimum(int)> scored 0.0
<lsp.test.jdk.util.Calendar: int getLeastMaximum(int)> scored 0.0
<lsp.test.jdk.util.Calendar: int getMaximum(int)> scored 0.0
<lsp.test.jdk.util.Calendar: int getMinimalDaysInFirstWeek()> scored 0.0
<lsp.test.jdk.util.Calendar: int getMinimum(int)> scored 0.0
<lsp.test.jdk.util.Calendar: long getTimeInMillis()> scored 0.0
<lsp.test.jdk.util.Calendar: int hashCode()> scored 0.0
<lsp.test.jdk.util.Calendar: int internalGet(int)> scored 0.0
<lsp.test.jdk.util.Calendar: boolean isLenient()> scored 0.0
<lsp.test.jdk.util.Calendar: boolean isSet(int)> scored 0.0
<lsp.test.jdk.util.Calendar: void roll(int,int)> scored 0.0
<lsp.test.jdk.util.Calendar: void roll(int,boolean)> scored 0.0
<lsp.test.jdk.util.Calendar: void set(int,int)> scored 0.0
<lsp.test.jdk.util.Calendar: void set(int,int,int)> scored 0.0
<lsp.test.jdk.util.Calendar: void set(int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.Calendar: void set(int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.Calendar: void setFirstDayOfWeek(int)> scored 0.0
<lsp.test.jdk.util.Calendar: void setLenient(boolean)> scored 0.0
<lsp.test.jdk.util.Calendar: void setMinimalDaysInFirstWeek(int)> scored 0.0
<lsp.test.jdk.util.Calendar: void setTimeInMillis(long)> scored 0.0
<lsp.test.jdk.util.Calendar: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Calendar: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.Calendar: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.Calendar: void <clinit>()> scored 0.0
<lsp.test.jdk.util.ICUResourceBundle$1: void <init>(java.lang.String,java.lang.ClassLoader)> scored 0.0
<lsp.test.jdk.util.NumberFormat$Field: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.NumberFormat$Field: void <clinit>()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$SingleFormatControl: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Collections$CopiesList: int size()> scored 0.0
<lsp.test.jdk.util.Collections$CopiesList: void <clinit>()> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void <init>()> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void <init>(int)> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void grow(int)> scored 0.0
<lsp.test.jdk.util.PriorityQueue: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.PriorityQueue: int size()> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void clear()> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void heapify()> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.PriorityQueue: void <clinit>()> scored 0.0
<lsp.test.jdk.util.UUID: void <init>(byte[])> scored 0.0
<lsp.test.jdk.util.UUID: void <init>(long,long)> scored 0.0
<lsp.test.jdk.util.UUID: long getLeastSignificantBits()> scored 0.0
<lsp.test.jdk.util.UUID: long getMostSignificantBits()> scored 0.0
<lsp.test.jdk.util.UUID: int version()> scored 0.0
<lsp.test.jdk.util.UUID: int variant()> scored 0.0
<lsp.test.jdk.util.UUID: long timestamp()> scored 0.0
<lsp.test.jdk.util.UUID: int clockSequence()> scored 0.0
<lsp.test.jdk.util.UUID: long node()> scored 0.0
<lsp.test.jdk.util.UUID: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.UUID: java.lang.String digits(long,int)> scored 0.0
<lsp.test.jdk.util.UUID: int hashCode()> scored 0.0
<lsp.test.jdk.util.UUID: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.UUID: void <clinit>()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap$LinkedHashIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap$LinkedHashIterator: void remove()> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeBoolean(boolean)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeByte(byte)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeShort(short)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeInt(int)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeLong(long)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeFloat(float)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeDouble(double)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeBigDecimal(java.math.BigDecimal)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeBytes(byte[])> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeCharacterStream(java.io.Reader)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeAsciiStream(java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeBinaryStream(java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeURL(java.net.URL)> scored 0.0
<lsp.test.jdk.util.sql.SQLOutput: void writeNString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void <init>(int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void <init>(int,java.lang.String,int,int,int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void <init>(int,java.lang.String,int,int,int,int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void <init>(int,java.lang.String,int,int,int,int,int,int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: int getDSTSavings()> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: int getOffset(int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: int getOffset(long)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: int getRawOffset()> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: int hashCode()> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: boolean isLeapYear(int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setDSTSavings(int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void checkRange(int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void checkDay(int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setEndMode()> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setEndRule(int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setEndRule(int,int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setEndRule(int,int,int,int,boolean)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setRawOffset(int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setStartMode()> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setStartRule(int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setStartRule(int,int,int,int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setStartRule(int,int,int,int,boolean)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void setStartYear(int)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: boolean useDaylightTime()> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.SimpleTimeZone: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Stack: void <init>()> scored 0.0
<lsp.test.jdk.util.Stack: boolean empty()> scored 0.0
<lsp.test.jdk.util.Map$Entry: int hashCode()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean allProceduresAreCallable()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean allTablesAreSelectable()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean dataDefinitionCausesTransactionCommit()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean dataDefinitionIgnoredInTransactions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean deletesAreDetected(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean doesMaxRowSizeIncludeBlobs()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getCatalogSeparator()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getCatalogTerm()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getDatabaseMajorVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getDatabaseMinorVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getDatabaseProductName()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getDatabaseProductVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getDefaultTransactionIsolation()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getDriverMajorVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getDriverMinorVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getDriverName()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getDriverVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getExtraNameCharacters()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getIdentifierQuoteString()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getJDBCMajorVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getJDBCMinorVersion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxBinaryLiteralLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxCatalogNameLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxCharLiteralLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxColumnNameLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxColumnsInGroupBy()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxColumnsInIndex()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxColumnsInOrderBy()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxColumnsInSelect()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxColumnsInTable()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxConnections()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxCursorNameLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxIndexLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxProcedureNameLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxRowSize()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxSchemaNameLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxStatementLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxStatements()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxTableNameLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxTablesInSelect()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getMaxUserNameLength()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getNumericFunctions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getProcedureTerm()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getResultSetHoldability()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getSchemaTerm()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getSearchStringEscape()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getSQLKeywords()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: int getSQLStateType()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getStringFunctions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getSystemFunctions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getTimeDateFunctions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getURL()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: java.lang.String getUserName()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean insertsAreDetected(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean isCatalogAtStart()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean isReadOnly()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean locatorsUpdateCopy()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean nullPlusNonNullIsNull()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean nullsAreSortedAtEnd()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean nullsAreSortedAtStart()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean nullsAreSortedHigh()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean nullsAreSortedLow()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean othersDeletesAreVisible(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean othersInsertsAreVisible(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean othersUpdatesAreVisible(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean ownDeletesAreVisible(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean ownInsertsAreVisible(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean ownUpdatesAreVisible(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean storesLowerCaseIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean storesLowerCaseQuotedIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean storesMixedCaseIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean storesMixedCaseQuotedIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean storesUpperCaseIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean storesUpperCaseQuotedIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsAlterTableWithAddColumn()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsAlterTableWithDropColumn()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsANSI92EntryLevelSQL()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsANSI92FullSQL()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsANSI92IntermediateSQL()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsBatchUpdates()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsCatalogsInDataManipulation()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsCatalogsInIndexDefinitions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsCatalogsInPrivilegeDefinitions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsCatalogsInProcedureCalls()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsCatalogsInTableDefinitions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsColumnAliasing()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsConvert()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsConvert(int,int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsCoreSQLGrammar()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsCorrelatedSubqueries()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsDataDefinitionAndDataManipulationTransactions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsDataManipulationTransactionsOnly()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsDifferentTableCorrelationNames()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsExpressionsInOrderBy()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsExtendedSQLGrammar()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsFullOuterJoins()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsGetGeneratedKeys()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsGroupBy()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsGroupByBeyondSelect()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsGroupByUnrelated()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsIntegrityEnhancementFacility()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsLikeEscapeClause()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsLimitedOuterJoins()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsMinimumSQLGrammar()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsMixedCaseIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsMixedCaseQuotedIdentifiers()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsMultipleOpenResults()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsMultipleResultSets()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsMultipleTransactions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsNamedParameters()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsNonNullableColumns()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsOpenCursorsAcrossCommit()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsOpenCursorsAcrossRollback()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsOpenStatementsAcrossCommit()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsOpenStatementsAcrossRollback()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsOrderByUnrelated()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsOuterJoins()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsPositionedDelete()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsPositionedUpdate()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsResultSetConcurrency(int,int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsResultSetHoldability(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsResultSetType(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSavepoints()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSchemasInDataManipulation()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSchemasInIndexDefinitions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSchemasInPrivilegeDefinitions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSchemasInProcedureCalls()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSchemasInTableDefinitions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSelectForUpdate()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsStatementPooling()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsStoredProcedures()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSubqueriesInComparisons()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSubqueriesInExists()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSubqueriesInIns()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsSubqueriesInQuantifieds()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsTableCorrelationNames()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsTransactionIsolationLevel(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsTransactions()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsUnion()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsUnionAll()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean updatesAreDetected(int)> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean usesLocalFilePerTable()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean usesLocalFiles()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean supportsStoredFunctionsUsingCallSyntax()> scored 0.0
<lsp.test.jdk.util.sql.DatabaseMetaData: boolean autoCommitFailureClosesAllResultSets()> scored 0.0
<lsp.test.jdk.util.sql.SQLException$InternalIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.sql.SQLException$InternalIterator: java.lang.Throwable next()> scored 0.0
<lsp.test.jdk.util.sql.SQLException$InternalIterator: void remove()> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLSyntaxErrorException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.util.Iterator keyIterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: java.util.Iterator descendingKeyIterator()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.TreeMap$NavigableSubMap: int size()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedList: int hashCode()> scored 0.0
<lsp.test.jdk.util.Map: int size()> scored 0.0
<lsp.test.jdk.util.Map: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Map: void clear()> scored 0.0
<lsp.test.jdk.util.Map: int hashCode()> scored 0.0
<lsp.test.jdk.util.NumberFormat: void <init>()> scored 0.0
<lsp.test.jdk.util.NumberFormat: java.lang.String format(double)> scored 0.0
<lsp.test.jdk.util.NumberFormat: java.lang.String format(long)> scored 0.0
<lsp.test.jdk.util.NumberFormat: int getMaximumFractionDigits()> scored 0.0
<lsp.test.jdk.util.NumberFormat: int getMaximumIntegerDigits()> scored 0.0
<lsp.test.jdk.util.NumberFormat: int getMinimumFractionDigits()> scored 0.0
<lsp.test.jdk.util.NumberFormat: int getMinimumIntegerDigits()> scored 0.0
<lsp.test.jdk.util.NumberFormat: int hashCode()> scored 0.0
<lsp.test.jdk.util.NumberFormat: boolean isGroupingUsed()> scored 0.0
<lsp.test.jdk.util.NumberFormat: boolean isParseIntegerOnly()> scored 0.0
<lsp.test.jdk.util.NumberFormat: java.lang.Number parse(java.lang.String)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void setGroupingUsed(boolean)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void setMaximumFractionDigits(int)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void setMaximumIntegerDigits(int)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void setMinimumFractionDigits(int)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void setMinimumIntegerDigits(int)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void setParseIntegerOnly(boolean)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.NumberFormat: java.math.RoundingMode getRoundingMode()> scored 0.0
<lsp.test.jdk.util.NumberFormat: void setRoundingMode(java.math.RoundingMode)> scored 0.0
<lsp.test.jdk.util.NumberFormat: void <clinit>()> scored 0.0
<lsp.test.jdk.util.sql.Time: void <init>(int,int,int)> scored 0.0
<lsp.test.jdk.util.sql.Time: void <init>(long)> scored 0.0
<lsp.test.jdk.util.sql.Time: int getDate()> scored 0.0
<lsp.test.jdk.util.sql.Time: int getDay()> scored 0.0
<lsp.test.jdk.util.sql.Time: int getMonth()> scored 0.0
<lsp.test.jdk.util.sql.Time: int getYear()> scored 0.0
<lsp.test.jdk.util.sql.Time: void setDate(int)> scored 0.0
<lsp.test.jdk.util.sql.Time: void setMonth(int)> scored 0.0
<lsp.test.jdk.util.sql.Time: void setYear(int)> scored 0.0
<lsp.test.jdk.util.sql.Time: void setTime(long)> scored 0.0
<lsp.test.jdk.util.sql.Time: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.sql.Time: void format(int,int,java.lang.StringBuilder)> scored 0.0
<lsp.test.jdk.util.HashSet: void <init>()> scored 0.0
<lsp.test.jdk.util.HashSet: void <init>(int,float)> scored 0.0
<lsp.test.jdk.util.HashSet: void <init>(int)> scored 0.0
<lsp.test.jdk.util.HashSet: void <init>(int,float,boolean)> scored 0.0
<lsp.test.jdk.util.HashSet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.HashSet: int size()> scored 0.0
<lsp.test.jdk.util.HashSet: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.HashSet: void clear()> scored 0.0
<lsp.test.jdk.util.HashSet: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.HashSet: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.HashSet: void <clinit>()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: java.lang.String readString()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: boolean readBoolean()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: byte readByte()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: short readShort()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: int readInt()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: long readLong()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: float readFloat()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: double readDouble()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: java.math.BigDecimal readBigDecimal()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: byte[] readBytes()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: java.io.Reader readCharacterStream()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: java.io.InputStream readAsciiStream()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: java.io.InputStream readBinaryStream()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: boolean wasNull()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: java.net.URL readURL()> scored 0.0
<lsp.test.jdk.util.sql.SQLInput: java.lang.String readNString()> scored 0.0
<lsp.test.jdk.util.Date: void <init>()> scored 0.0
<lsp.test.jdk.util.Date: void <init>(int,int,int)> scored 0.0
<lsp.test.jdk.util.Date: void <init>(int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.Date: void <init>(int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.Date: void <init>(long)> scored 0.0
<lsp.test.jdk.util.Date: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.Date: int getDate()> scored 0.0
<lsp.test.jdk.util.Date: int getDay()> scored 0.0
<lsp.test.jdk.util.Date: int getHours()> scored 0.0
<lsp.test.jdk.util.Date: int getMinutes()> scored 0.0
<lsp.test.jdk.util.Date: int getMonth()> scored 0.0
<lsp.test.jdk.util.Date: int getSeconds()> scored 0.0
<lsp.test.jdk.util.Date: long getTime()> scored 0.0
<lsp.test.jdk.util.Date: int getTimezoneOffset()> scored 0.0
<lsp.test.jdk.util.Date: int getYear()> scored 0.0
<lsp.test.jdk.util.Date: int hashCode()> scored 0.0
<lsp.test.jdk.util.Date: int parse(java.lang.String,java.lang.String[])> scored 0.0
<lsp.test.jdk.util.Date: long parse(java.lang.String)> scored 0.0
<lsp.test.jdk.util.Date: void setDate(int)> scored 0.0
<lsp.test.jdk.util.Date: void setHours(int)> scored 0.0
<lsp.test.jdk.util.Date: void setMinutes(int)> scored 0.0
<lsp.test.jdk.util.Date: void setMonth(int)> scored 0.0
<lsp.test.jdk.util.Date: void setSeconds(int)> scored 0.0
<lsp.test.jdk.util.Date: void setTime(long)> scored 0.0
<lsp.test.jdk.util.Date: void setYear(int)> scored 0.0
<lsp.test.jdk.util.Date: java.lang.String toGMTString()> scored 0.0
<lsp.test.jdk.util.Date: java.lang.String toLocaleString()> scored 0.0
<lsp.test.jdk.util.Date: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Date: java.lang.String toTwoDigits(int)> scored 0.0
<lsp.test.jdk.util.Date: long UTC(int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.Date: int zone(java.lang.String)> scored 0.0
<lsp.test.jdk.util.Date: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.Date: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.Date: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Hashtable$ValueCollection: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Hashtable$ValueCollection: int size()> scored 0.0
<lsp.test.jdk.util.Hashtable$ValueCollection: void clear()> scored 0.0
<lsp.test.jdk.util.Hashtable$EntrySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Hashtable$EntrySet: int size()> scored 0.0
<lsp.test.jdk.util.Hashtable$EntrySet: void clear()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$IdentityHashMapIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$IdentityHashMapIterator: int nextIndex()> scored 0.0
<lsp.test.jdk.util.IdentityHashMap$IdentityHashMapIterator: void remove()> scored 0.0
<lsp.test.jdk.util.Properties$LineReader: int readLine()> scored 0.0
<lsp.test.jdk.util.InputMismatchException: void <init>()> scored 0.0
<lsp.test.jdk.util.InputMismatchException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AbstractList$Itr: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.AbstractList$Itr: void remove()> scored 0.0
<lsp.test.jdk.util.AbstractList$Itr: void checkForComodification()> scored 0.0
<lsp.test.jdk.util.TreeMap: void <init>()> scored 0.0
<lsp.test.jdk.util.TreeMap: int size()> scored 0.0
<lsp.test.jdk.util.TreeMap: void clear()> scored 0.0
<lsp.test.jdk.util.TreeMap: java.util.Iterator keyIterator()> scored 0.0
<lsp.test.jdk.util.TreeMap: java.util.Iterator descendingKeyIterator()> scored 0.0
<lsp.test.jdk.util.TreeMap: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.TreeMap: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.TreeMap: int computeRedLevel(int)> scored 0.0
<lsp.test.jdk.util.EnumMap$EntrySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.EnumMap$EntrySet: int size()> scored 0.0
<lsp.test.jdk.util.EnumMap$EntrySet: void clear()> scored 0.0
<lsp.test.jdk.util.sql.Struct: java.lang.String getSQLTypeName()> scored 0.0
<lsp.test.jdk.util.EnumMap$Values: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.EnumMap$Values: int size()> scored 0.0
<lsp.test.jdk.util.EnumMap$Values: void clear()> scored 0.0
<lsp.test.jdk.util.BreakIterator: void <init>()> scored 0.0
<lsp.test.jdk.util.BreakIterator: boolean isBoundary(int)> scored 0.0
<lsp.test.jdk.util.BreakIterator: int preceding(int)> scored 0.0
<lsp.test.jdk.util.BreakIterator: void setText(java.lang.String)> scored 0.0
<lsp.test.jdk.util.BreakIterator: int current()> scored 0.0
<lsp.test.jdk.util.BreakIterator: int first()> scored 0.0
<lsp.test.jdk.util.BreakIterator: int following(int)> scored 0.0
<lsp.test.jdk.util.BreakIterator: int last()> scored 0.0
<lsp.test.jdk.util.BreakIterator: int next()> scored 0.0
<lsp.test.jdk.util.BreakIterator: int next(int)> scored 0.0
<lsp.test.jdk.util.BreakIterator: int previous()> scored 0.0
<lsp.test.jdk.util.BreakIterator: long getLong(byte[],int)> scored 0.0
<lsp.test.jdk.util.BreakIterator: int getInt(byte[],int)> scored 0.0
<lsp.test.jdk.util.BreakIterator: short getShort(byte[],int)> scored 0.0
<lsp.test.jdk.util.FieldPosition: void <init>(int)> scored 0.0
<lsp.test.jdk.util.FieldPosition: void clear()> scored 0.0
<lsp.test.jdk.util.FieldPosition: int getBeginIndex()> scored 0.0
<lsp.test.jdk.util.FieldPosition: int getEndIndex()> scored 0.0
<lsp.test.jdk.util.FieldPosition: int getField()> scored 0.0
<lsp.test.jdk.util.FieldPosition: int hashCode()> scored 0.0
<lsp.test.jdk.util.FieldPosition: void setBeginIndex(int)> scored 0.0
<lsp.test.jdk.util.FieldPosition: void setEndIndex(int)> scored 0.0
<lsp.test.jdk.util.FieldPosition: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap$UnmodifiableEntrySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void <init>(java.lang.String,boolean)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void reset()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void append(char)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void addSeparator()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getString(int)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void set(int,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void append(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: char next()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void skipUntilTerminatorOrIDSeparator()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean atTerminator()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean isTerminator(char)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean isTerminatorOrIDSeparator(char)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean haveExperimentalLanguagePrefix()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean haveKeywordAssign()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: int parseLanguage()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void skipLanguage()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: int parseScript()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void skipScript()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: int parseCountry()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void skipCountry()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: int parseVariant()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getLanguage()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getScript()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getCountry()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getVariant()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String[] getLanguageScriptCountryVariant()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void setBaseName(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void parseBaseName()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getBaseName()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getName()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean setToKeywordStart()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean isDoneOrKeywordAssign(char)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: boolean isDoneOrItemSeparator(char)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getKeyword()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getValue()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: int parseKeywords()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.util.Iterator getKeywords()> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: java.lang.String getKeywordValue(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void defaultKeywordValue(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void setKeywordValue(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.ULocale$IDParser: void setKeywordValue(java.lang.String,java.lang.String,boolean)> scored 0.0
<lsp.test.jdk.util.AsciiUtil$CaseInsensitiveKey: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil$CaseInsensitiveKey: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedSet: int hashCode()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: char current()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: char first()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getBeginIndex()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getEndIndex()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getIndex()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getRunLimit()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: int getRunStart()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: char last()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: char next()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: char previous()> scored 0.0
<lsp.test.jdk.util.AttributedString$AttributedIterator: char setIndex(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: java.lang.String getParameterClassName(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: int getParameterCount()> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: int getParameterMode(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: int getParameterType(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: java.lang.String getParameterTypeName(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: int getPrecision(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: int getScale(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: int isNullable(int)> scored 0.0
<lsp.test.jdk.util.sql.ParameterMetaData: boolean isSigned(int)> scored 0.0
<lsp.test.jdk.util.EnumMap$EntryIterator: java.lang.Enum getKey()> scored 0.0
<lsp.test.jdk.util.EnumMap$EntryIterator: int hashCode()> scored 0.0
<lsp.test.jdk.util.EnumMap$EntryIterator: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.EnumMap$EntryIterator: void checkLastReturnedIndexForEntryUse()> scored 0.0
<lsp.test.jdk.util.Collections$EmptyList: void <init>()> scored 0.0
<lsp.test.jdk.util.Collections$EmptyList: int size()> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLNonTransientConnectionException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.Collections$SingletonMap: int size()> scored 0.0
<lsp.test.jdk.util.Collections$SingletonMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.sql.Clob: java.io.InputStream getAsciiStream()> scored 0.0
<lsp.test.jdk.util.sql.Clob: java.io.Reader getCharacterStream()> scored 0.0
<lsp.test.jdk.util.sql.Clob: java.lang.String getSubString(long,int)> scored 0.0
<lsp.test.jdk.util.sql.Clob: long length()> scored 0.0
<lsp.test.jdk.util.sql.Clob: long position(java.lang.String,long)> scored 0.0
<lsp.test.jdk.util.sql.Clob: java.io.OutputStream setAsciiStream(long)> scored 0.0
<lsp.test.jdk.util.sql.Clob: java.io.Writer setCharacterStream(long)> scored 0.0
<lsp.test.jdk.util.sql.Clob: int setString(long,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Clob: int setString(long,java.lang.String,int,int)> scored 0.0
<lsp.test.jdk.util.sql.Clob: void truncate(long)> scored 0.0
<lsp.test.jdk.util.sql.Clob: void free()> scored 0.0
<lsp.test.jdk.util.sql.Clob: java.io.Reader getCharacterStream(long,long)> scored 0.0
<lsp.test.jdk.util.EnumMap$KeyIterator: java.lang.Enum next()> scored 0.0
<lsp.test.jdk.util.Collections$ReverseComparator2: void <clinit>()> scored 0.0
<lsp.test.jdk.util.AbstractMap$2: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.AbstractMap$2: int size()> scored 0.0
<lsp.test.jdk.util.NoSuchElementException: void <init>()> scored 0.0
<lsp.test.jdk.util.NoSuchElementException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Types: void <init>()> scored 0.0
<lsp.test.jdk.util.Format$Field: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.UnknownFormatConversionException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.UnknownFormatConversionException: java.lang.String getConversion()> scored 0.0
<lsp.test.jdk.util.UnknownFormatConversionException: java.lang.String getMessage()> scored 0.0
<lsp.test.jdk.util.ICUCache: void clear()> scored 0.0
<lsp.test.jdk.util.ICUCache: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedMap: int size()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedMap: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedMap: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedMap: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$SynchronizedMap: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.AbstractSet: void <init>()> scored 0.0
<lsp.test.jdk.util.AbstractSet: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$SingletonList: int size()> scored 0.0
<lsp.test.jdk.util.HashMap$EntrySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.HashMap$EntrySet: int size()> scored 0.0
<lsp.test.jdk.util.HashMap$EntrySet: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: int size()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$UnmodifiableMap: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.sql.Connection: void clearWarnings()> scored 0.0
<lsp.test.jdk.util.sql.Connection: void close()> scored 0.0
<lsp.test.jdk.util.sql.Connection: void commit()> scored 0.0
<lsp.test.jdk.util.sql.Connection: boolean getAutoCommit()> scored 0.0
<lsp.test.jdk.util.sql.Connection: java.lang.String getCatalog()> scored 0.0
<lsp.test.jdk.util.sql.Connection: int getHoldability()> scored 0.0
<lsp.test.jdk.util.sql.Connection: int getTransactionIsolation()> scored 0.0
<lsp.test.jdk.util.sql.Connection: boolean isClosed()> scored 0.0
<lsp.test.jdk.util.sql.Connection: boolean isReadOnly()> scored 0.0
<lsp.test.jdk.util.sql.Connection: java.lang.String nativeSQL(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Connection: void rollback()> scored 0.0
<lsp.test.jdk.util.sql.Connection: void setAutoCommit(boolean)> scored 0.0
<lsp.test.jdk.util.sql.Connection: void setCatalog(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Connection: void setHoldability(int)> scored 0.0
<lsp.test.jdk.util.sql.Connection: void setReadOnly(boolean)> scored 0.0
<lsp.test.jdk.util.sql.Connection: void setTransactionIsolation(int)> scored 0.0
<lsp.test.jdk.util.sql.Connection: boolean isValid(int)> scored 0.0
<lsp.test.jdk.util.sql.Connection: void setClientInfo(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.Connection: java.lang.String getClientInfo(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ArrayList: void <init>(int)> scored 0.0
<lsp.test.jdk.util.ArrayList: void <init>()> scored 0.0
<lsp.test.jdk.util.ArrayList: void trimToSize()> scored 0.0
<lsp.test.jdk.util.ArrayList: void ensureCapacity(int)> scored 0.0
<lsp.test.jdk.util.ArrayList: int size()> scored 0.0
<lsp.test.jdk.util.ArrayList: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.ArrayList: void fastRemove(int)> scored 0.0
<lsp.test.jdk.util.ArrayList: void clear()> scored 0.0
<lsp.test.jdk.util.ArrayList: void removeRange(int,int)> scored 0.0
<lsp.test.jdk.util.ArrayList: void RangeCheck(int)> scored 0.0
<lsp.test.jdk.util.ArrayList: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.ArrayList: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.ResourceBundle: void <init>()> scored 0.0
<lsp.test.jdk.util.ResourceBundle: java.lang.String getString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ResourceBundle: java.lang.String[] getStringArray(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ResourceBundle: java.lang.ClassLoader getLoader()> scored 0.0
<lsp.test.jdk.util.ResourceBundle: void clearCache()> scored 0.0
<lsp.test.jdk.util.ResourceBundle: void clearCache(java.lang.ClassLoader)> scored 0.0
<lsp.test.jdk.util.ResourceBundle: boolean containsKey(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ResourceBundle: java.lang.ref.ReferenceQueue access$200()> scored 0.0
<lsp.test.jdk.util.ResourceBundle: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Collections$EmptySet$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$EmptySet$1: void remove()> scored 0.0
<lsp.test.jdk.util.UResourceBundle$ResourceCacheKey: void <init>()> scored 0.0
<lsp.test.jdk.util.UResourceBundle$ResourceCacheKey: int hashCode()> scored 0.0
<lsp.test.jdk.util.List: int size()> scored 0.0
<lsp.test.jdk.util.List: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.List: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.List: void clear()> scored 0.0
<lsp.test.jdk.util.List: int hashCode()> scored 0.0
<lsp.test.jdk.util.Currency: void <init>(java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.Currency: java.lang.String getCurrencyCode()> scored 0.0
<lsp.test.jdk.util.Currency: java.lang.String getSymbol()> scored 0.0
<lsp.test.jdk.util.Currency: java.lang.String getSymbol(java.util.Locale)> scored 0.0
<lsp.test.jdk.util.Currency: int getDefaultFractionDigits()> scored 0.0
<lsp.test.jdk.util.Currency: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Currency: int getMainTableEntry(char,char)> scored 0.0
<lsp.test.jdk.util.Currency: void <clinit>()> scored 0.0
<lsp.test.jdk.util.TreeMap$PrivateEntryIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.TreeMap$PrivateEntryIterator: void remove()> scored 0.0
<lsp.test.jdk.util.LinkedHashMap$Entry: void remove()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: int size()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: int hashCode()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: void clear()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedMap$CheckedEntrySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.sql.SQLClientInfoException: void <init>()> scored 0.0
<lsp.test.jdk.util.AsciiUtil: void <init>()> scored 0.0
<lsp.test.jdk.util.AsciiUtil: boolean caseIgnoreMatch(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: int caseIgnoreCompare(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: char toUpper(char)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: char toLower(char)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: java.lang.String toLowerString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: java.lang.String toUpperString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: java.lang.String toTitleString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: boolean isAlpha(char)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: boolean isAlphaString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: boolean isNumeric(char)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: boolean isNumericString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: boolean isAlphaNumeric(char)> scored 0.0
<lsp.test.jdk.util.AsciiUtil: boolean isAlphaNumericString(java.lang.String)> scored 0.0
<lsp.test.jdk.util.IllegalFormatException: void <init>()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$1: void <init>()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$1: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.Dictionary: void <init>()> scored 0.0
<lsp.test.jdk.util.Dictionary: int size()> scored 0.0
<lsp.test.jdk.util.Dictionary: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader: void <init>()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader: java.net.URL getResource(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader: java.io.InputStream getResourceAsStream(java.lang.String)> scored 0.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Arrays$ArrayList: int size()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void <init>()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String[] getAmPmStrings()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String[] getEras()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String getLocalPatternChars()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String[] getMonths()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String[] getShortMonths()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String[] getShortWeekdays()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String[] getWeekdays()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: java.lang.String[][] getZoneStrings()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: int hashCode()> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setAmPmStrings(java.lang.String[])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setEras(java.lang.String[])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setLocalPatternChars(java.lang.String)> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setMonths(java.lang.String[])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setShortMonths(java.lang.String[])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setShortWeekdays(java.lang.String[])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setWeekdays(java.lang.String[])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void setZoneStrings(java.lang.String[][])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void validateZoneStrings(java.lang.String[][])> scored 0.0
<lsp.test.jdk.util.DateFormatSymbols: void <clinit>()> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: void <init>(int,int,int,int,int,int,int)> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: void <init>(long)> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: int getNanos()> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: long getTime()> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: void setNanos(int)> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: void setTime(long)> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: void setTimeImpl(long)> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.sql.Timestamp: void format(int,int,java.lang.StringBuilder)> scored 0.0
<lsp.test.jdk.util.Collections$CheckedCollection$1: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.Collections$CheckedCollection$1: void remove()> scored 0.0
<lsp.test.jdk.util.NavigableSet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.NavigableSet: java.util.Iterator descendingIterator()> scored 0.0
<lsp.test.jdk.util.ConcurrentModificationException: void <init>()> scored 0.0
<lsp.test.jdk.util.ConcurrentModificationException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: int hashCode()> scored 0.0
<lsp.test.jdk.util.AbstractMap$SimpleImmutableEntry: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.HashMap$Values: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.HashMap$Values: int size()> scored 0.0
<lsp.test.jdk.util.HashMap$Values: void clear()> scored 0.0
<lsp.test.jdk.util.EnumMap$KeySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.EnumMap$KeySet: int size()> scored 0.0
<lsp.test.jdk.util.EnumMap$KeySet: void clear()> scored 0.0
<lsp.test.jdk.util.HashMap: void <init>(int,float)> scored 0.0
<lsp.test.jdk.util.HashMap: void <init>(int)> scored 0.0
<lsp.test.jdk.util.HashMap: void <init>()> scored 0.0
<lsp.test.jdk.util.HashMap: void init()> scored 0.0
<lsp.test.jdk.util.HashMap: int hash(int)> scored 0.0
<lsp.test.jdk.util.HashMap: int indexFor(int,int)> scored 0.0
<lsp.test.jdk.util.HashMap: int size()> scored 0.0
<lsp.test.jdk.util.HashMap: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.HashMap: void resize(int)> scored 0.0
<lsp.test.jdk.util.HashMap: void clear()> scored 0.0
<lsp.test.jdk.util.HashMap: boolean containsNullValue()> scored 0.0
<lsp.test.jdk.util.HashMap: java.util.Iterator newKeyIterator()> scored 0.0
<lsp.test.jdk.util.HashMap: java.util.Iterator newValueIterator()> scored 0.0
<lsp.test.jdk.util.HashMap: java.util.Iterator newEntryIterator()> scored 0.0
<lsp.test.jdk.util.HashMap: void writeObject(java.io.ObjectOutputStream)> scored 0.0
<lsp.test.jdk.util.HashMap: void readObject(java.io.ObjectInputStream)> scored 0.0
<lsp.test.jdk.util.HashMap: int capacity()> scored 0.0
<lsp.test.jdk.util.HashMap: float loadFactor()> scored 0.0
<lsp.test.jdk.util.HashMap$Entry: int hashCode()> scored 0.0
<lsp.test.jdk.util.HashMap$Entry: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.sql.Array: int getBaseType()> scored 0.0
<lsp.test.jdk.util.sql.Array: java.lang.String getBaseTypeName()> scored 0.0
<lsp.test.jdk.util.sql.Array: void free()> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>(java.lang.String,java.lang.String,int)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>(java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>(java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>(java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.sql.SQLTransactionRollbackException: void <init>(java.lang.String,java.lang.String,int,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.Hashtable$KeySet: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Hashtable$KeySet: int size()> scored 0.0
<lsp.test.jdk.util.Hashtable$KeySet: void clear()> scored 0.0
<lsp.test.jdk.util.ListIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.ListIterator: boolean hasPrevious()> scored 0.0
<lsp.test.jdk.util.ListIterator: int nextIndex()> scored 0.0
<lsp.test.jdk.util.ListIterator: int previousIndex()> scored 0.0
<lsp.test.jdk.util.ListIterator: void remove()> scored 0.0
<lsp.test.jdk.util.TreeMap$AscendingSubMap$AscendingEntrySetView: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.MissingResourceException: void <init>(java.lang.String,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.MissingResourceException: void <init>(java.lang.String,java.lang.String,java.lang.String,java.lang.Throwable)> scored 0.0
<lsp.test.jdk.util.MissingResourceException: java.lang.String getClassName()> scored 0.0
<lsp.test.jdk.util.MissingResourceException: java.lang.String getKey()> scored 0.0
<lsp.test.jdk.util.LinkedList$DescendingIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.LinkedList$DescendingIterator: void remove()> scored 0.0
<lsp.test.jdk.util.ResourceBundle$RBClassLoader$1: void <init>()> scored 0.0
<lsp.test.jdk.util.XMLUtils$EH: void <init>()> scored 0.0
<lsp.test.jdk.util.XMLUtils$EH: void error(org.xml.sax.SAXParseException)> scored 0.0
<lsp.test.jdk.util.XMLUtils$EH: void fatalError(org.xml.sax.SAXParseException)> scored 0.0
<lsp.test.jdk.util.XMLUtils$EH: void warning(org.xml.sax.SAXParseException)> scored 0.0
<lsp.test.jdk.util.Properties: void <init>()> scored 0.0
<lsp.test.jdk.util.Properties: void load(java.io.Reader)> scored 0.0
<lsp.test.jdk.util.Properties: void load(java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.Properties: java.lang.String loadConvert(char[],int,int,char[])> scored 0.0
<lsp.test.jdk.util.Properties: java.lang.String saveConvert(java.lang.String,boolean,boolean)> scored 0.0
<lsp.test.jdk.util.Properties: void writeComments(java.io.BufferedWriter,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: void save(java.io.OutputStream,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: void store(java.io.Writer,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: void store(java.io.OutputStream,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: void store0(java.io.BufferedWriter,java.lang.String,boolean)> scored 0.0
<lsp.test.jdk.util.Properties: void loadFromXML(java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.Properties: void storeToXML(java.io.OutputStream,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: void storeToXML(java.io.OutputStream,java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: java.lang.String getProperty(java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: java.lang.String getProperty(java.lang.String,java.lang.String)> scored 0.0
<lsp.test.jdk.util.Properties: void list(java.io.PrintStream)> scored 0.0
<lsp.test.jdk.util.Properties: void list(java.io.PrintWriter)> scored 0.0
<lsp.test.jdk.util.Properties: char toHex(int)> scored 0.0
<lsp.test.jdk.util.Properties: void <clinit>()> scored 0.0
<lsp.test.jdk.util.XMLUtils: void <init>()> scored 0.0
<lsp.test.jdk.util.XMLUtils: org.w3c.dom.Document getLoadingDoc(java.io.InputStream)> scored 0.0
<lsp.test.jdk.util.XMLUtils: void emitDocument(org.w3c.dom.Document,java.io.OutputStream,java.lang.String)> scored 0.0
<lsp.test.jdk.util.XMLUtils: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Set: int size()> scored 0.0
<lsp.test.jdk.util.Set: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Set: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Set: void clear()> scored 0.0
<lsp.test.jdk.util.Set: int hashCode()> scored 0.0
<lsp.test.jdk.util.EnumMap$EnumMapIterator: boolean hasNext()> scored 0.0
<lsp.test.jdk.util.EnumMap$EnumMapIterator: void remove()> scored 0.0
<lsp.test.jdk.util.EnumMap$EnumMapIterator: void checkLastReturnedIndex()> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void loadInitialDrivers()> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void <init>()> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: int getLoginTimeout()> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: java.io.PrintStream getLogStream()> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: java.io.PrintWriter getLogWriter()> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void println(java.lang.String)> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void setLoginTimeout(int)> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void setLogStream(java.io.PrintStream)> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void setLogWriter(java.io.PrintWriter)> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void checkLogSecurity()> scored 0.0
<lsp.test.jdk.util.sql.DriverManager: void <clinit>()> scored 0.0
<lsp.test.jdk.util.Collection: int size()> scored 0.0
<lsp.test.jdk.util.Collection: boolean isEmpty()> scored 0.0
<lsp.test.jdk.util.Collection: java.util.Iterator iterator()> scored 0.0
<lsp.test.jdk.util.Collection: void clear()> scored 0.0
<lsp.test.jdk.util.Collection: int hashCode()> scored 0.0
<lsp.test.jdk.util.sql.Ref: java.lang.String getBaseTypeName()> scored 0.0
<lsp.test.jdk.util.sql.RowId: byte[] getBytes()> scored 0.0
<lsp.test.jdk.util.sql.RowId: java.lang.String toString()> scored 0.0
<lsp.test.jdk.util.sql.RowId: int hashCode()> scored 0.0
